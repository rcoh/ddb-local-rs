// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// Describes one specific validation failure for an input member.
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct ValidationExceptionField  {
    /// A JSONPointer expression to the structure member whose value failed to satisfy the modeled constraints.
    pub path: ::std::string::String,
    /// A detailed description of the validation failure.
    pub message: ::std::string::String,
}
impl  ValidationExceptionField  {
    /// A JSONPointer expression to the structure member whose value failed to satisfy the modeled constraints.
    pub fn path(&self) -> &str {
        use std::ops::Deref; self.path.deref()
    }
    /// A detailed description of the validation failure.
    pub fn message(&self) -> &str {
        use std::ops::Deref; self.message.deref()
    }
}
impl  ValidationExceptionField  {
    /// Creates a new builder-style object to manufacture [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    pub fn builder() -> crate::model::validation_exception_field::Builder  {
        crate::model::validation_exception_field::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct TableDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub attribute_definitions: ::std::option::Option<::std::vec::Vec::<crate::model::AttributeDefinition>>,
    #[allow(missing_docs)] // documentation missing in model
    pub table_name: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub key_schema: ::std::option::Option<::std::vec::Vec::<crate::model::KeySchemaElement>>,
    #[allow(missing_docs)] // documentation missing in model
    pub table_status: ::std::option::Option<crate::model::TableStatus>,
    #[allow(missing_docs)] // documentation missing in model
    pub creation_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    pub provisioned_throughput: ::std::option::Option<crate::model::ProvisionedThroughputDescription>,
    #[allow(missing_docs)] // documentation missing in model
    pub table_size_bytes: ::std::option::Option<i64>,
    #[allow(missing_docs)] // documentation missing in model
    pub item_count: ::std::option::Option<i64>,
    #[allow(missing_docs)] // documentation missing in model
    pub table_arn: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub table_id: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub billing_mode_summary: ::std::option::Option<crate::model::BillingModeSummary>,
    #[allow(missing_docs)] // documentation missing in model
    pub local_secondary_indexes: ::std::option::Option<::std::vec::Vec::<crate::model::LocalSecondaryIndexDescription>>,
    #[allow(missing_docs)] // documentation missing in model
    pub global_secondary_indexes: ::std::option::Option<::std::vec::Vec::<crate::model::GlobalSecondaryIndexDescription>>,
    #[allow(missing_docs)] // documentation missing in model
    pub stream_specification: ::std::option::Option<crate::model::StreamSpecification>,
    #[allow(missing_docs)] // documentation missing in model
    pub latest_stream_label: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub latest_stream_arn: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub global_table_version: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub replicas: ::std::option::Option<::std::vec::Vec::<crate::model::ReplicaDescription>>,
    #[allow(missing_docs)] // documentation missing in model
    pub restore_summary: ::std::option::Option<crate::model::RestoreSummary>,
    #[allow(missing_docs)] // documentation missing in model
    pub sse_description: ::std::option::Option<crate::model::SseDescription>,
    #[allow(missing_docs)] // documentation missing in model
    pub archival_summary: ::std::option::Option<crate::model::ArchivalSummary>,
}
impl  TableDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn attribute_definitions(&self) -> ::std::option::Option<&[crate::model::AttributeDefinition]> {
        self.attribute_definitions.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_name(&self) -> ::std::option::Option<&str> {
        self.table_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn key_schema(&self) -> ::std::option::Option<&[crate::model::KeySchemaElement]> {
        self.key_schema.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_status(&self) -> ::std::option::Option<&crate::model::TableStatus> {
        self.table_status.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn creation_date_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.creation_date_time.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn provisioned_throughput(&self) -> ::std::option::Option<&crate::model::ProvisionedThroughputDescription> {
        self.provisioned_throughput.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_size_bytes(&self) -> ::std::option::Option<i64> {
        self.table_size_bytes
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn item_count(&self) -> ::std::option::Option<i64> {
        self.item_count
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_arn(&self) -> ::std::option::Option<&str> {
        self.table_arn.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_id(&self) -> ::std::option::Option<&str> {
        self.table_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn billing_mode_summary(&self) -> ::std::option::Option<&crate::model::BillingModeSummary> {
        self.billing_mode_summary.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn local_secondary_indexes(&self) -> ::std::option::Option<&[crate::model::LocalSecondaryIndexDescription]> {
        self.local_secondary_indexes.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn global_secondary_indexes(&self) -> ::std::option::Option<&[crate::model::GlobalSecondaryIndexDescription]> {
        self.global_secondary_indexes.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn stream_specification(&self) -> ::std::option::Option<&crate::model::StreamSpecification> {
        self.stream_specification.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn latest_stream_label(&self) -> ::std::option::Option<&str> {
        self.latest_stream_label.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn latest_stream_arn(&self) -> ::std::option::Option<&str> {
        self.latest_stream_arn.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn global_table_version(&self) -> ::std::option::Option<&str> {
        self.global_table_version.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn replicas(&self) -> ::std::option::Option<&[crate::model::ReplicaDescription]> {
        self.replicas.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn restore_summary(&self) -> ::std::option::Option<&crate::model::RestoreSummary> {
        self.restore_summary.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn sse_description(&self) -> ::std::option::Option<&crate::model::SseDescription> {
        self.sse_description.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn archival_summary(&self) -> ::std::option::Option<&crate::model::ArchivalSummary> {
        self.archival_summary.as_ref()
    }
}
impl  TableDescription  {
    /// Creates a new builder-style object to manufacture [`TableDescription`](crate::model::TableDescription).
    pub fn builder() -> crate::model::table_description::Builder  {
        crate::model::table_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct ArchivalSummary  {
    #[allow(missing_docs)] // documentation missing in model
    pub archival_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    pub archival_reason: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub archival_backup_arn: ::std::option::Option<::std::string::String>,
}
impl  ArchivalSummary  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn archival_date_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.archival_date_time.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn archival_reason(&self) -> ::std::option::Option<&str> {
        self.archival_reason.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn archival_backup_arn(&self) -> ::std::option::Option<&str> {
        self.archival_backup_arn.as_deref()
    }
}
impl  ArchivalSummary  {
    /// Creates a new builder-style object to manufacture [`ArchivalSummary`](crate::model::ArchivalSummary).
    pub fn builder() -> crate::model::archival_summary::Builder  {
        crate::model::archival_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct SseDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub status: ::std::option::Option<crate::model::SSEStatus>,
    #[allow(missing_docs)] // documentation missing in model
    pub sse_type: ::std::option::Option<crate::model::SSEType>,
    #[allow(missing_docs)] // documentation missing in model
    pub kms_master_key_arn: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub inaccessible_encryption_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
}
impl  SseDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn status(&self) -> ::std::option::Option<&crate::model::SSEStatus> {
        self.status.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn sse_type(&self) -> ::std::option::Option<&crate::model::SSEType> {
        self.sse_type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn kms_master_key_arn(&self) -> ::std::option::Option<&str> {
        self.kms_master_key_arn.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn inaccessible_encryption_date_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.inaccessible_encryption_date_time.as_ref()
    }
}
impl  SseDescription  {
    /// Creates a new builder-style object to manufacture [`SseDescription`](crate::model::SseDescription).
    pub fn builder() -> crate::model::sse_description::Builder  {
        crate::model::sse_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum SSEType {
    #[allow(missing_docs)] // documentation missing in model
    Aes256,
    #[allow(missing_docs)] // documentation missing in model
    Kms,
}
/// See [`SSEType`](crate::model::SSEType).
pub mod sse_type {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#SSEType' failed to satisfy constraint: Member must satisfy enum value set: [AES256, KMS]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [AES256, KMS]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for SSEType {
                    type Error = crate::model::sse_type::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "AES256" => Ok(SSEType::Aes256),
"KMS" => Ok(SSEType::Kms),
                            _ => Err(crate::model::sse_type::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for SSEType {
                    type Error = crate::model::sse_type::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for SSEType {
                    type Err = crate::model::sse_type::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl SSEType {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    SSEType::Aes256 => "AES256",
    SSEType::Kms => "KMS",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["AES256", "KMS"]
                }
            }
impl ::std::convert::AsRef<str> for SSEType {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for SSEType  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::SSEType> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum SSEStatus {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Disabling,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabling,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
}
/// See [`SSEStatus`](crate::model::SSEStatus).
pub mod sse_status {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#SSEStatus' failed to satisfy constraint: Member must satisfy enum value set: [ENABLING, ENABLED, DISABLING, DISABLED, UPDATING]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    
    
}
impl ::std::convert::TryFrom<&str> for SSEStatus {
                    type Error = crate::model::sse_status::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "DISABLED" => Ok(SSEStatus::Disabled),
"DISABLING" => Ok(SSEStatus::Disabling),
"ENABLED" => Ok(SSEStatus::Enabled),
"ENABLING" => Ok(SSEStatus::Enabling),
"UPDATING" => Ok(SSEStatus::Updating),
                            _ => Err(crate::model::sse_status::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for SSEStatus {
                    type Error = crate::model::sse_status::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for SSEStatus {
                    type Err = crate::model::sse_status::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl SSEStatus {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    SSEStatus::Disabled => "DISABLED",
    SSEStatus::Disabling => "DISABLING",
    SSEStatus::Enabled => "ENABLED",
    SSEStatus::Enabling => "ENABLING",
    SSEStatus::Updating => "UPDATING",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["DISABLED", "DISABLING", "ENABLED", "ENABLING", "UPDATING"]
                }
            }
impl ::std::convert::AsRef<str> for SSEStatus {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for SSEStatus  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::SSEStatus> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct RestoreSummary  {
    #[allow(missing_docs)] // documentation missing in model
    pub source_backup_arn: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub source_table_arn: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub restore_date_time: ::aws_smithy_types::DateTime,
    #[allow(missing_docs)] // documentation missing in model
    pub restore_in_progress: bool,
}
impl  RestoreSummary  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn source_backup_arn(&self) -> ::std::option::Option<&str> {
        self.source_backup_arn.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn source_table_arn(&self) -> ::std::option::Option<&str> {
        self.source_table_arn.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn restore_date_time(&self) -> &::aws_smithy_types::DateTime {
        &self.restore_date_time
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn restore_in_progress(&self) -> bool {
        self.restore_in_progress
    }
}
impl  RestoreSummary  {
    /// Creates a new builder-style object to manufacture [`RestoreSummary`](crate::model::RestoreSummary).
    pub fn builder() -> crate::model::restore_summary::Builder  {
        crate::model::restore_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct ReplicaDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub region_name: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub replica_status: ::std::option::Option<crate::model::ReplicaStatus>,
    #[allow(missing_docs)] // documentation missing in model
    pub replica_status_description: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub replica_status_percent_progress: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub kms_master_key_id: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub provisioned_throughput_override: ::std::option::Option<crate::model::ProvisionedThroughputOverride>,
    #[allow(missing_docs)] // documentation missing in model
    pub global_secondary_indexes: ::std::option::Option<::std::vec::Vec::<crate::model::ReplicaGlobalSecondaryIndexDescription>>,
    #[allow(missing_docs)] // documentation missing in model
    pub replica_inaccessible_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
}
impl  ReplicaDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn region_name(&self) -> ::std::option::Option<&str> {
        self.region_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn replica_status(&self) -> ::std::option::Option<&crate::model::ReplicaStatus> {
        self.replica_status.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn replica_status_description(&self) -> ::std::option::Option<&str> {
        self.replica_status_description.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn replica_status_percent_progress(&self) -> ::std::option::Option<&str> {
        self.replica_status_percent_progress.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn kms_master_key_id(&self) -> ::std::option::Option<&str> {
        self.kms_master_key_id.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn provisioned_throughput_override(&self) -> ::std::option::Option<&crate::model::ProvisionedThroughputOverride> {
        self.provisioned_throughput_override.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn global_secondary_indexes(&self) -> ::std::option::Option<&[crate::model::ReplicaGlobalSecondaryIndexDescription]> {
        self.global_secondary_indexes.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn replica_inaccessible_date_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.replica_inaccessible_date_time.as_ref()
    }
}
impl  ReplicaDescription  {
    /// Creates a new builder-style object to manufacture [`ReplicaDescription`](crate::model::ReplicaDescription).
    pub fn builder() -> crate::model::replica_description::Builder  {
        crate::model::replica_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct ReplicaGlobalSecondaryIndexDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub index_name: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub provisioned_throughput_override: ::std::option::Option<crate::model::ProvisionedThroughputOverride>,
}
impl  ReplicaGlobalSecondaryIndexDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn index_name(&self) -> ::std::option::Option<&str> {
        self.index_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn provisioned_throughput_override(&self) -> ::std::option::Option<&crate::model::ProvisionedThroughputOverride> {
        self.provisioned_throughput_override.as_ref()
    }
}
impl  ReplicaGlobalSecondaryIndexDescription  {
    /// Creates a new builder-style object to manufacture [`ReplicaGlobalSecondaryIndexDescription`](crate::model::ReplicaGlobalSecondaryIndexDescription).
    pub fn builder() -> crate::model::replica_global_secondary_index_description::Builder  {
        crate::model::replica_global_secondary_index_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct ProvisionedThroughputOverride  {
    #[allow(missing_docs)] // documentation missing in model
    pub read_capacity_units: ::std::option::Option<i64>,
}
impl  ProvisionedThroughputOverride  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn read_capacity_units(&self) -> ::std::option::Option<i64> {
        self.read_capacity_units
    }
}
impl  ProvisionedThroughputOverride  {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughputOverride`](crate::model::ProvisionedThroughputOverride).
    pub fn builder() -> crate::model::provisioned_throughput_override::Builder  {
        crate::model::provisioned_throughput_override::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum ReplicaStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    CreationFailed,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    InaccessibleEncryptionCredentials,
    #[allow(missing_docs)] // documentation missing in model
    RegionDisabled,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
}
/// See [`ReplicaStatus`](crate::model::ReplicaStatus).
pub mod replica_status {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#ReplicaStatus' failed to satisfy constraint: Member must satisfy enum value set: [CREATING, CREATION_FAILED, UPDATING, DELETING, ACTIVE, REGION_DISABLED, INACCESSIBLE_ENCRYPTION_CREDENTIALS]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    
    
}
impl ::std::convert::TryFrom<&str> for ReplicaStatus {
                    type Error = crate::model::replica_status::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "ACTIVE" => Ok(ReplicaStatus::Active),
"CREATING" => Ok(ReplicaStatus::Creating),
"CREATION_FAILED" => Ok(ReplicaStatus::CreationFailed),
"DELETING" => Ok(ReplicaStatus::Deleting),
"INACCESSIBLE_ENCRYPTION_CREDENTIALS" => Ok(ReplicaStatus::InaccessibleEncryptionCredentials),
"REGION_DISABLED" => Ok(ReplicaStatus::RegionDisabled),
"UPDATING" => Ok(ReplicaStatus::Updating),
                            _ => Err(crate::model::replica_status::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for ReplicaStatus {
                    type Error = crate::model::replica_status::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for ReplicaStatus {
                    type Err = crate::model::replica_status::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl ReplicaStatus {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    ReplicaStatus::Active => "ACTIVE",
    ReplicaStatus::Creating => "CREATING",
    ReplicaStatus::CreationFailed => "CREATION_FAILED",
    ReplicaStatus::Deleting => "DELETING",
    ReplicaStatus::InaccessibleEncryptionCredentials => "INACCESSIBLE_ENCRYPTION_CREDENTIALS",
    ReplicaStatus::RegionDisabled => "REGION_DISABLED",
    ReplicaStatus::Updating => "UPDATING",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["ACTIVE", "CREATING", "CREATION_FAILED", "DELETING", "INACCESSIBLE_ENCRYPTION_CREDENTIALS", "REGION_DISABLED", "UPDATING"]
                }
            }
impl ::std::convert::AsRef<str> for ReplicaStatus {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for ReplicaStatus  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::ReplicaStatus> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct StreamSpecification  {
    #[allow(missing_docs)] // documentation missing in model
    pub stream_enabled: bool,
    #[allow(missing_docs)] // documentation missing in model
    pub stream_view_type: ::std::option::Option<crate::model::StreamViewType>,
}
impl  StreamSpecification  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn stream_enabled(&self) -> bool {
        self.stream_enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn stream_view_type(&self) -> ::std::option::Option<&crate::model::StreamViewType> {
        self.stream_view_type.as_ref()
    }
}
impl  StreamSpecification  {
    /// Creates a new builder-style object to manufacture [`StreamSpecification`](crate::model::StreamSpecification).
    pub fn builder() -> crate::model::stream_specification::Builder  {
        crate::model::stream_specification::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::StreamSpecification {
                type Unconstrained = crate::model::stream_specification::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum StreamViewType {
    #[allow(missing_docs)] // documentation missing in model
    KeysOnly,
    #[allow(missing_docs)] // documentation missing in model
    NewAndOldImages,
    #[allow(missing_docs)] // documentation missing in model
    NewImage,
    #[allow(missing_docs)] // documentation missing in model
    OldImage,
}
/// See [`StreamViewType`](crate::model::StreamViewType).
pub mod stream_view_type {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#StreamViewType' failed to satisfy constraint: Member must satisfy enum value set: [NEW_IMAGE, OLD_IMAGE, NEW_AND_OLD_IMAGES, KEYS_ONLY]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [NEW_IMAGE, OLD_IMAGE, NEW_AND_OLD_IMAGES, KEYS_ONLY]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for StreamViewType {
                    type Error = crate::model::stream_view_type::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "KEYS_ONLY" => Ok(StreamViewType::KeysOnly),
"NEW_AND_OLD_IMAGES" => Ok(StreamViewType::NewAndOldImages),
"NEW_IMAGE" => Ok(StreamViewType::NewImage),
"OLD_IMAGE" => Ok(StreamViewType::OldImage),
                            _ => Err(crate::model::stream_view_type::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for StreamViewType {
                    type Error = crate::model::stream_view_type::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for StreamViewType {
                    type Err = crate::model::stream_view_type::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl StreamViewType {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    StreamViewType::KeysOnly => "KEYS_ONLY",
    StreamViewType::NewAndOldImages => "NEW_AND_OLD_IMAGES",
    StreamViewType::NewImage => "NEW_IMAGE",
    StreamViewType::OldImage => "OLD_IMAGE",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["KEYS_ONLY", "NEW_AND_OLD_IMAGES", "NEW_IMAGE", "OLD_IMAGE"]
                }
            }
impl ::std::convert::AsRef<str> for StreamViewType {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for StreamViewType  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::StreamViewType> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct GlobalSecondaryIndexDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub index_name: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub key_schema: ::std::option::Option<::std::vec::Vec::<crate::model::KeySchemaElement>>,
    #[allow(missing_docs)] // documentation missing in model
    pub projection: ::std::option::Option<crate::model::Projection>,
    #[allow(missing_docs)] // documentation missing in model
    pub index_status: ::std::option::Option<crate::model::IndexStatus>,
    #[allow(missing_docs)] // documentation missing in model
    pub backfilling: ::std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub provisioned_throughput: ::std::option::Option<crate::model::ProvisionedThroughputDescription>,
    #[allow(missing_docs)] // documentation missing in model
    pub index_size_bytes: ::std::option::Option<i64>,
    #[allow(missing_docs)] // documentation missing in model
    pub item_count: ::std::option::Option<i64>,
    #[allow(missing_docs)] // documentation missing in model
    pub index_arn: ::std::option::Option<::std::string::String>,
}
impl  GlobalSecondaryIndexDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn index_name(&self) -> ::std::option::Option<&str> {
        self.index_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn key_schema(&self) -> ::std::option::Option<&[crate::model::KeySchemaElement]> {
        self.key_schema.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn projection(&self) -> ::std::option::Option<&crate::model::Projection> {
        self.projection.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn index_status(&self) -> ::std::option::Option<&crate::model::IndexStatus> {
        self.index_status.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn backfilling(&self) -> ::std::option::Option<bool> {
        self.backfilling
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn provisioned_throughput(&self) -> ::std::option::Option<&crate::model::ProvisionedThroughputDescription> {
        self.provisioned_throughput.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn index_size_bytes(&self) -> ::std::option::Option<i64> {
        self.index_size_bytes
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn item_count(&self) -> ::std::option::Option<i64> {
        self.item_count
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn index_arn(&self) -> ::std::option::Option<&str> {
        self.index_arn.as_deref()
    }
}
impl  GlobalSecondaryIndexDescription  {
    /// Creates a new builder-style object to manufacture [`GlobalSecondaryIndexDescription`](crate::model::GlobalSecondaryIndexDescription).
    pub fn builder() -> crate::model::global_secondary_index_description::Builder  {
        crate::model::global_secondary_index_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct ProvisionedThroughputDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub last_increase_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    pub last_decrease_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    #[allow(missing_docs)] // documentation missing in model
    pub number_of_decreases_today: ::std::option::Option<i64>,
    #[allow(missing_docs)] // documentation missing in model
    pub read_capacity_units: ::std::option::Option<i64>,
    #[allow(missing_docs)] // documentation missing in model
    pub write_capacity_units: ::std::option::Option<i64>,
}
impl  ProvisionedThroughputDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn last_increase_date_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_increase_date_time.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn last_decrease_date_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_decrease_date_time.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn number_of_decreases_today(&self) -> ::std::option::Option<i64> {
        self.number_of_decreases_today
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn read_capacity_units(&self) -> ::std::option::Option<i64> {
        self.read_capacity_units
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn write_capacity_units(&self) -> ::std::option::Option<i64> {
        self.write_capacity_units
    }
}
impl  ProvisionedThroughputDescription  {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughputDescription`](crate::model::ProvisionedThroughputDescription).
    pub fn builder() -> crate::model::provisioned_throughput_description::Builder  {
        crate::model::provisioned_throughput_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum IndexStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
}
/// See [`IndexStatus`](crate::model::IndexStatus).
pub mod index_status {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#IndexStatus' failed to satisfy constraint: Member must satisfy enum value set: [CREATING, UPDATING, DELETING, ACTIVE]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    
    
}
impl ::std::convert::TryFrom<&str> for IndexStatus {
                    type Error = crate::model::index_status::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "ACTIVE" => Ok(IndexStatus::Active),
"CREATING" => Ok(IndexStatus::Creating),
"DELETING" => Ok(IndexStatus::Deleting),
"UPDATING" => Ok(IndexStatus::Updating),
                            _ => Err(crate::model::index_status::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for IndexStatus {
                    type Error = crate::model::index_status::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for IndexStatus {
                    type Err = crate::model::index_status::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl IndexStatus {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    IndexStatus::Active => "ACTIVE",
    IndexStatus::Creating => "CREATING",
    IndexStatus::Deleting => "DELETING",
    IndexStatus::Updating => "UPDATING",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["ACTIVE", "CREATING", "DELETING", "UPDATING"]
                }
            }
impl ::std::convert::AsRef<str> for IndexStatus {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for IndexStatus  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::IndexStatus> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct Projection  {
    #[allow(missing_docs)] // documentation missing in model
    pub projection_type: ::std::option::Option<crate::model::ProjectionType>,
    #[allow(missing_docs)] // documentation missing in model
    pub non_key_attributes: ::std::option::Option<::std::vec::Vec::<::std::string::String>>,
}
impl  Projection  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn projection_type(&self) -> ::std::option::Option<&crate::model::ProjectionType> {
        self.projection_type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn non_key_attributes(&self) -> ::std::option::Option<&[::std::string::String]> {
        self.non_key_attributes.as_deref()
    }
}
impl  Projection  {
    /// Creates a new builder-style object to manufacture [`Projection`](crate::model::Projection).
    pub fn builder() -> crate::model::projection::Builder  {
        crate::model::projection::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::Projection {
                type Unconstrained = crate::model::projection::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum ProjectionType {
    #[allow(missing_docs)] // documentation missing in model
    All,
    #[allow(missing_docs)] // documentation missing in model
    Include,
    #[allow(missing_docs)] // documentation missing in model
    KeysOnly,
}
/// See [`ProjectionType`](crate::model::ProjectionType).
pub mod projection_type {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#ProjectionType' failed to satisfy constraint: Member must satisfy enum value set: [ALL, KEYS_ONLY, INCLUDE]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [ALL, KEYS_ONLY, INCLUDE]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for ProjectionType {
                    type Error = crate::model::projection_type::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "ALL" => Ok(ProjectionType::All),
"INCLUDE" => Ok(ProjectionType::Include),
"KEYS_ONLY" => Ok(ProjectionType::KeysOnly),
                            _ => Err(crate::model::projection_type::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for ProjectionType {
                    type Error = crate::model::projection_type::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for ProjectionType {
                    type Err = crate::model::projection_type::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl ProjectionType {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    ProjectionType::All => "ALL",
    ProjectionType::Include => "INCLUDE",
    ProjectionType::KeysOnly => "KEYS_ONLY",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["ALL", "INCLUDE", "KEYS_ONLY"]
                }
            }
impl ::std::convert::AsRef<str> for ProjectionType {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for ProjectionType  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::ProjectionType> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }



#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct KeySchemaElement  {
    #[allow(missing_docs)] // documentation missing in model
    pub attribute_name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub key_type: crate::model::KeyType,
}
impl  KeySchemaElement  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn attribute_name(&self) -> &str {
        use std::ops::Deref; self.attribute_name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn key_type(&self) -> &crate::model::KeyType {
        &self.key_type
    }
}
impl  KeySchemaElement  {
    /// Creates a new builder-style object to manufacture [`KeySchemaElement`](crate::model::KeySchemaElement).
    pub fn builder() -> crate::model::key_schema_element::Builder  {
        crate::model::key_schema_element::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::KeySchemaElement {
                type Unconstrained = crate::model::key_schema_element::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum KeyType {
    #[allow(missing_docs)] // documentation missing in model
    Hash,
    #[allow(missing_docs)] // documentation missing in model
    Range,
}
/// See [`KeyType`](crate::model::KeyType).
pub mod key_type {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#KeyType' failed to satisfy constraint: Member must satisfy enum value set: [HASH, RANGE]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [HASH, RANGE]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for KeyType {
                    type Error = crate::model::key_type::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "HASH" => Ok(KeyType::Hash),
"RANGE" => Ok(KeyType::Range),
                            _ => Err(crate::model::key_type::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for KeyType {
                    type Error = crate::model::key_type::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for KeyType {
                    type Err = crate::model::key_type::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl KeyType {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    KeyType::Hash => "HASH",
    KeyType::Range => "RANGE",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["HASH", "RANGE"]
                }
            }
impl ::std::convert::AsRef<str> for KeyType {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for KeyType  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::KeyType> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct LocalSecondaryIndexDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub index_name: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub key_schema: ::std::option::Option<::std::vec::Vec::<crate::model::KeySchemaElement>>,
    #[allow(missing_docs)] // documentation missing in model
    pub projection: ::std::option::Option<crate::model::Projection>,
    #[allow(missing_docs)] // documentation missing in model
    pub index_size_bytes: ::std::option::Option<i64>,
    #[allow(missing_docs)] // documentation missing in model
    pub item_count: ::std::option::Option<i64>,
    #[allow(missing_docs)] // documentation missing in model
    pub index_arn: ::std::option::Option<::std::string::String>,
}
impl  LocalSecondaryIndexDescription  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn index_name(&self) -> ::std::option::Option<&str> {
        self.index_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn key_schema(&self) -> ::std::option::Option<&[crate::model::KeySchemaElement]> {
        self.key_schema.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn projection(&self) -> ::std::option::Option<&crate::model::Projection> {
        self.projection.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn index_size_bytes(&self) -> ::std::option::Option<i64> {
        self.index_size_bytes
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn item_count(&self) -> ::std::option::Option<i64> {
        self.item_count
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn index_arn(&self) -> ::std::option::Option<&str> {
        self.index_arn.as_deref()
    }
}
impl  LocalSecondaryIndexDescription  {
    /// Creates a new builder-style object to manufacture [`LocalSecondaryIndexDescription`](crate::model::LocalSecondaryIndexDescription).
    pub fn builder() -> crate::model::local_secondary_index_description::Builder  {
        crate::model::local_secondary_index_description::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct BillingModeSummary  {
    #[allow(missing_docs)] // documentation missing in model
    pub billing_mode: ::std::option::Option<crate::model::BillingMode>,
    #[allow(missing_docs)] // documentation missing in model
    pub last_update_to_pay_per_request_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
}
impl  BillingModeSummary  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn billing_mode(&self) -> ::std::option::Option<&crate::model::BillingMode> {
        self.billing_mode.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn last_update_to_pay_per_request_date_time(&self) -> ::std::option::Option<&::aws_smithy_types::DateTime> {
        self.last_update_to_pay_per_request_date_time.as_ref()
    }
}
impl  BillingModeSummary  {
    /// Creates a new builder-style object to manufacture [`BillingModeSummary`](crate::model::BillingModeSummary).
    pub fn builder() -> crate::model::billing_mode_summary::Builder  {
        crate::model::billing_mode_summary::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum BillingMode {
    #[allow(missing_docs)] // documentation missing in model
    PayPerRequest,
    #[allow(missing_docs)] // documentation missing in model
    Provisioned,
}
/// See [`BillingMode`](crate::model::BillingMode).
pub mod billing_mode {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#BillingMode' failed to satisfy constraint: Member must satisfy enum value set: [PROVISIONED, PAY_PER_REQUEST]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [PROVISIONED, PAY_PER_REQUEST]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for BillingMode {
                    type Error = crate::model::billing_mode::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "PAY_PER_REQUEST" => Ok(BillingMode::PayPerRequest),
"PROVISIONED" => Ok(BillingMode::Provisioned),
                            _ => Err(crate::model::billing_mode::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for BillingMode {
                    type Error = crate::model::billing_mode::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for BillingMode {
                    type Err = crate::model::billing_mode::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl BillingMode {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    BillingMode::PayPerRequest => "PAY_PER_REQUEST",
    BillingMode::Provisioned => "PROVISIONED",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["PAY_PER_REQUEST", "PROVISIONED"]
                }
            }
impl ::std::convert::AsRef<str> for BillingMode {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for BillingMode  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::BillingMode> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum TableStatus {
    #[allow(missing_docs)] // documentation missing in model
    Active,
    #[allow(missing_docs)] // documentation missing in model
    Archived,
    #[allow(missing_docs)] // documentation missing in model
    Archiving,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    #[allow(missing_docs)] // documentation missing in model
    InaccessibleEncryptionCredentials,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
}
/// See [`TableStatus`](crate::model::TableStatus).
pub mod table_status {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#TableStatus' failed to satisfy constraint: Member must satisfy enum value set: [CREATING, UPDATING, DELETING, ACTIVE, INACCESSIBLE_ENCRYPTION_CREDENTIALS, ARCHIVING, ARCHIVED]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    
    
}
impl ::std::convert::TryFrom<&str> for TableStatus {
                    type Error = crate::model::table_status::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "ACTIVE" => Ok(TableStatus::Active),
"ARCHIVED" => Ok(TableStatus::Archived),
"ARCHIVING" => Ok(TableStatus::Archiving),
"CREATING" => Ok(TableStatus::Creating),
"DELETING" => Ok(TableStatus::Deleting),
"INACCESSIBLE_ENCRYPTION_CREDENTIALS" => Ok(TableStatus::InaccessibleEncryptionCredentials),
"UPDATING" => Ok(TableStatus::Updating),
                            _ => Err(crate::model::table_status::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for TableStatus {
                    type Error = crate::model::table_status::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for TableStatus {
                    type Err = crate::model::table_status::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl TableStatus {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    TableStatus::Active => "ACTIVE",
    TableStatus::Archived => "ARCHIVED",
    TableStatus::Archiving => "ARCHIVING",
    TableStatus::Creating => "CREATING",
    TableStatus::Deleting => "DELETING",
    TableStatus::InaccessibleEncryptionCredentials => "INACCESSIBLE_ENCRYPTION_CREDENTIALS",
    TableStatus::Updating => "UPDATING",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["ACTIVE", "ARCHIVED", "ARCHIVING", "CREATING", "DELETING", "INACCESSIBLE_ENCRYPTION_CREDENTIALS", "UPDATING"]
                }
            }
impl ::std::convert::AsRef<str> for TableStatus {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for TableStatus  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::TableStatus> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }



#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct AttributeDefinition  {
    #[allow(missing_docs)] // documentation missing in model
    pub attribute_name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub attribute_type: crate::model::ScalarAttributeType,
}
impl  AttributeDefinition  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn attribute_name(&self) -> &str {
        use std::ops::Deref; self.attribute_name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn attribute_type(&self) -> &crate::model::ScalarAttributeType {
        &self.attribute_type
    }
}
impl  AttributeDefinition  {
    /// Creates a new builder-style object to manufacture [`AttributeDefinition`](crate::model::AttributeDefinition).
    pub fn builder() -> crate::model::attribute_definition::Builder  {
        crate::model::attribute_definition::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::AttributeDefinition {
                type Unconstrained = crate::model::attribute_definition::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum ScalarAttributeType {
    #[allow(missing_docs)] // documentation missing in model
    B,
    #[allow(missing_docs)] // documentation missing in model
    N,
    #[allow(missing_docs)] // documentation missing in model
    S,
}
/// See [`ScalarAttributeType`](crate::model::ScalarAttributeType).
pub mod scalar_attribute_type {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#ScalarAttributeType' failed to satisfy constraint: Member must satisfy enum value set: [S, N, B]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [S, N, B]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for ScalarAttributeType {
                    type Error = crate::model::scalar_attribute_type::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "B" => Ok(ScalarAttributeType::B),
"N" => Ok(ScalarAttributeType::N),
"S" => Ok(ScalarAttributeType::S),
                            _ => Err(crate::model::scalar_attribute_type::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for ScalarAttributeType {
                    type Error = crate::model::scalar_attribute_type::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for ScalarAttributeType {
                    type Err = crate::model::scalar_attribute_type::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl ScalarAttributeType {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    ScalarAttributeType::B => "B",
    ScalarAttributeType::N => "N",
    ScalarAttributeType::S => "S",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["B", "N", "S"]
                }
            }
impl ::std::convert::AsRef<str> for ScalarAttributeType {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for ScalarAttributeType  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::ScalarAttributeType> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }



#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct Tag  {
    #[allow(missing_docs)] // documentation missing in model
    pub key: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub value: ::std::string::String,
}
impl  Tag  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn key(&self) -> &str {
        use std::ops::Deref; self.key.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn value(&self) -> &str {
        use std::ops::Deref; self.value.deref()
    }
}
impl  Tag  {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder  {
        crate::model::tag::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::Tag {
                type Unconstrained = crate::model::tag::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct SseSpecification  {
    #[allow(missing_docs)] // documentation missing in model
    pub enabled: ::std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub sse_type: ::std::option::Option<crate::model::SSEType>,
    #[allow(missing_docs)] // documentation missing in model
    pub kms_master_key_id: ::std::option::Option<::std::string::String>,
}
impl  SseSpecification  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn enabled(&self) -> ::std::option::Option<bool> {
        self.enabled
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn sse_type(&self) -> ::std::option::Option<&crate::model::SSEType> {
        self.sse_type.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn kms_master_key_id(&self) -> ::std::option::Option<&str> {
        self.kms_master_key_id.as_deref()
    }
}
impl  SseSpecification  {
    /// Creates a new builder-style object to manufacture [`SseSpecification`](crate::model::SseSpecification).
    pub fn builder() -> crate::model::sse_specification::Builder  {
        crate::model::sse_specification::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::SseSpecification {
                type Unconstrained = crate::model::sse_specification::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct ProvisionedThroughput  {
    #[allow(missing_docs)] // documentation missing in model
    pub read_capacity_units: i64,
    #[allow(missing_docs)] // documentation missing in model
    pub write_capacity_units: i64,
}
impl  ProvisionedThroughput  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn read_capacity_units(&self) -> i64 {
        self.read_capacity_units
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn write_capacity_units(&self) -> i64 {
        self.write_capacity_units
    }
}
impl  ProvisionedThroughput  {
    /// Creates a new builder-style object to manufacture [`ProvisionedThroughput`](crate::model::ProvisionedThroughput).
    pub fn builder() -> crate::model::provisioned_throughput::Builder  {
        crate::model::provisioned_throughput::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::ProvisionedThroughput {
                type Unconstrained = crate::model::provisioned_throughput::Builder;
            }



#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct GlobalSecondaryIndex  {
    #[allow(missing_docs)] // documentation missing in model
    pub index_name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub key_schema: ::std::vec::Vec::<crate::model::KeySchemaElement>,
    #[allow(missing_docs)] // documentation missing in model
    pub projection: crate::model::Projection,
    #[allow(missing_docs)] // documentation missing in model
    pub provisioned_throughput: ::std::option::Option<crate::model::ProvisionedThroughput>,
}
impl  GlobalSecondaryIndex  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn index_name(&self) -> &str {
        use std::ops::Deref; self.index_name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn key_schema(&self) -> &[crate::model::KeySchemaElement] {
        use std::ops::Deref; self.key_schema.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn projection(&self) -> &crate::model::Projection {
        &self.projection
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn provisioned_throughput(&self) -> ::std::option::Option<&crate::model::ProvisionedThroughput> {
        self.provisioned_throughput.as_ref()
    }
}
impl  GlobalSecondaryIndex  {
    /// Creates a new builder-style object to manufacture [`GlobalSecondaryIndex`](crate::model::GlobalSecondaryIndex).
    pub fn builder() -> crate::model::global_secondary_index::Builder  {
        crate::model::global_secondary_index::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::GlobalSecondaryIndex {
                type Unconstrained = crate::model::global_secondary_index::Builder;
            }



#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash)]
pub struct LocalSecondaryIndex  {
    #[allow(missing_docs)] // documentation missing in model
    pub index_name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub key_schema: ::std::vec::Vec::<crate::model::KeySchemaElement>,
    #[allow(missing_docs)] // documentation missing in model
    pub projection: crate::model::Projection,
}
impl  LocalSecondaryIndex  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn index_name(&self) -> &str {
        use std::ops::Deref; self.index_name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn key_schema(&self) -> &[crate::model::KeySchemaElement] {
        use std::ops::Deref; self.key_schema.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn projection(&self) -> &crate::model::Projection {
        &self.projection
    }
}
impl  LocalSecondaryIndex  {
    /// Creates a new builder-style object to manufacture [`LocalSecondaryIndex`](crate::model::LocalSecondaryIndex).
    pub fn builder() -> crate::model::local_secondary_index::Builder  {
        crate::model::local_secondary_index::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::LocalSecondaryIndex {
                type Unconstrained = crate::model::local_secondary_index::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ItemCollectionMetrics  {
    #[allow(missing_docs)] // documentation missing in model
    pub item_collection_key: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>,
    #[allow(missing_docs)] // documentation missing in model
    pub size_estimate_range_gb: ::std::option::Option<::std::vec::Vec::<f64>>,
}
impl  ItemCollectionMetrics  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn item_collection_key(&self) -> ::std::option::Option<&::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>> {
        self.item_collection_key.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn size_estimate_range_gb(&self) -> ::std::option::Option<&[f64]> {
        self.size_estimate_range_gb.as_deref()
    }
}
impl  ItemCollectionMetrics  {
    /// Creates a new builder-style object to manufacture [`ItemCollectionMetrics`](crate::model::ItemCollectionMetrics).
    pub fn builder() -> crate::model::item_collection_metrics::Builder  {
        crate::model::item_collection_metrics::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub enum AttributeValue {
    #[allow(missing_docs)] // documentation missing in model
    B(::aws_smithy_types::Blob),
    #[allow(missing_docs)] // documentation missing in model
    Bool(bool),
    #[allow(missing_docs)] // documentation missing in model
    Bs(::std::vec::Vec::<::aws_smithy_types::Blob>),
    #[allow(missing_docs)] // documentation missing in model
    L(::std::vec::Vec::<crate::model::AttributeValue>),
    #[allow(missing_docs)] // documentation missing in model
    M(::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>),
    #[allow(missing_docs)] // documentation missing in model
    N(::std::string::String),
    #[allow(missing_docs)] // documentation missing in model
    Ns(::std::vec::Vec::<::std::string::String>),
    #[allow(missing_docs)] // documentation missing in model
    Null(bool),
    #[allow(missing_docs)] // documentation missing in model
    S(::std::string::String),
    #[allow(missing_docs)] // documentation missing in model
    Ss(::std::vec::Vec::<::std::string::String>),
}
impl AttributeValue {
    /// Tries to convert the enum instance into [`B`](crate::model::AttributeValue::B), extracting the inner [`Blob`](::aws_smithy_types::Blob).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_b(&self) -> ::std::result::Result<&::aws_smithy_types::Blob, &Self> {
        if let AttributeValue::B(val) = &self { ::std::result::Result::Ok(val) } else { ::std::result::Result::Err(self) }
    }
    /// Returns true if this is a [`B`](crate::model::AttributeValue::B).
    pub fn is_b(&self) -> bool {
        self.as_b().is_ok()
    }
    /// Tries to convert the enum instance into [`Bool`](crate::model::AttributeValue::Bool), extracting the inner [`bool`](bool).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_bool(&self) -> ::std::result::Result<&bool, &Self> {
        if let AttributeValue::Bool(val) = &self { ::std::result::Result::Ok(val) } else { ::std::result::Result::Err(self) }
    }
    /// Returns true if this is a [`Bool`](crate::model::AttributeValue::Bool).
    pub fn is_bool(&self) -> bool {
        self.as_bool().is_ok()
    }
    /// Tries to convert the enum instance into [`Bs`](crate::model::AttributeValue::Bs), extracting the inner [`Vec`](::std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_bs(&self) -> ::std::result::Result<&::std::vec::Vec::<::aws_smithy_types::Blob>, &Self> {
        if let AttributeValue::Bs(val) = &self { ::std::result::Result::Ok(val) } else { ::std::result::Result::Err(self) }
    }
    /// Returns true if this is a [`Bs`](crate::model::AttributeValue::Bs).
    pub fn is_bs(&self) -> bool {
        self.as_bs().is_ok()
    }
    /// Tries to convert the enum instance into [`L`](crate::model::AttributeValue::L), extracting the inner [`Vec`](::std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_l(&self) -> ::std::result::Result<&::std::vec::Vec::<crate::model::AttributeValue>, &Self> {
        if let AttributeValue::L(val) = &self { ::std::result::Result::Ok(val) } else { ::std::result::Result::Err(self) }
    }
    /// Returns true if this is a [`L`](crate::model::AttributeValue::L).
    pub fn is_l(&self) -> bool {
        self.as_l().is_ok()
    }
    /// Tries to convert the enum instance into [`M`](crate::model::AttributeValue::M), extracting the inner [`HashMap`](::std::collections::HashMap).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_m(&self) -> ::std::result::Result<&::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>, &Self> {
        if let AttributeValue::M(val) = &self { ::std::result::Result::Ok(val) } else { ::std::result::Result::Err(self) }
    }
    /// Returns true if this is a [`M`](crate::model::AttributeValue::M).
    pub fn is_m(&self) -> bool {
        self.as_m().is_ok()
    }
    /// Tries to convert the enum instance into [`N`](crate::model::AttributeValue::N), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_n(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let AttributeValue::N(val) = &self { ::std::result::Result::Ok(val) } else { ::std::result::Result::Err(self) }
    }
    /// Returns true if this is a [`N`](crate::model::AttributeValue::N).
    pub fn is_n(&self) -> bool {
        self.as_n().is_ok()
    }
    /// Tries to convert the enum instance into [`Ns`](crate::model::AttributeValue::Ns), extracting the inner [`Vec`](::std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_ns(&self) -> ::std::result::Result<&::std::vec::Vec::<::std::string::String>, &Self> {
        if let AttributeValue::Ns(val) = &self { ::std::result::Result::Ok(val) } else { ::std::result::Result::Err(self) }
    }
    /// Returns true if this is a [`Ns`](crate::model::AttributeValue::Ns).
    pub fn is_ns(&self) -> bool {
        self.as_ns().is_ok()
    }
    /// Tries to convert the enum instance into [`Null`](crate::model::AttributeValue::Null), extracting the inner [`bool`](bool).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_null(&self) -> ::std::result::Result<&bool, &Self> {
        if let AttributeValue::Null(val) = &self { ::std::result::Result::Ok(val) } else { ::std::result::Result::Err(self) }
    }
    /// Returns true if this is a [`Null`](crate::model::AttributeValue::Null).
    pub fn is_null(&self) -> bool {
        self.as_null().is_ok()
    }
    /// Tries to convert the enum instance into [`S`](crate::model::AttributeValue::S), extracting the inner [`String`](::std::string::String).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_s(&self) -> ::std::result::Result<&::std::string::String, &Self> {
        if let AttributeValue::S(val) = &self { ::std::result::Result::Ok(val) } else { ::std::result::Result::Err(self) }
    }
    /// Returns true if this is a [`S`](crate::model::AttributeValue::S).
    pub fn is_s(&self) -> bool {
        self.as_s().is_ok()
    }
    /// Tries to convert the enum instance into [`Ss`](crate::model::AttributeValue::Ss), extracting the inner [`Vec`](::std::vec::Vec).
    /// Returns `Err(&Self)` if it can't be converted.
    pub fn as_ss(&self) -> ::std::result::Result<&::std::vec::Vec::<::std::string::String>, &Self> {
        if let AttributeValue::Ss(val) = &self { ::std::result::Result::Ok(val) } else { ::std::result::Result::Err(self) }
    }
    /// Returns true if this is a [`Ss`](crate::model::AttributeValue::Ss).
    pub fn is_ss(&self) -> bool {
        self.as_ss().is_ok()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ConsumedCapacity  {
    #[allow(missing_docs)] // documentation missing in model
    pub table_name: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub capacity_units: ::std::option::Option<f64>,
    #[allow(missing_docs)] // documentation missing in model
    pub read_capacity_units: ::std::option::Option<f64>,
    #[allow(missing_docs)] // documentation missing in model
    pub write_capacity_units: ::std::option::Option<f64>,
    #[allow(missing_docs)] // documentation missing in model
    pub table: ::std::option::Option<crate::model::Capacity>,
    #[allow(missing_docs)] // documentation missing in model
    pub local_secondary_indexes: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::Capacity>>,
    #[allow(missing_docs)] // documentation missing in model
    pub global_secondary_indexes: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::Capacity>>,
}
impl  ConsumedCapacity  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_name(&self) -> ::std::option::Option<&str> {
        self.table_name.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn capacity_units(&self) -> ::std::option::Option<f64> {
        self.capacity_units
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn read_capacity_units(&self) -> ::std::option::Option<f64> {
        self.read_capacity_units
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn write_capacity_units(&self) -> ::std::option::Option<f64> {
        self.write_capacity_units
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn table(&self) -> ::std::option::Option<&crate::model::Capacity> {
        self.table.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn local_secondary_indexes(&self) -> ::std::option::Option<&::std::collections::HashMap::<::std::string::String, crate::model::Capacity>> {
        self.local_secondary_indexes.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn global_secondary_indexes(&self) -> ::std::option::Option<&::std::collections::HashMap::<::std::string::String, crate::model::Capacity>> {
        self.global_secondary_indexes.as_ref()
    }
}
impl  ConsumedCapacity  {
    /// Creates a new builder-style object to manufacture [`ConsumedCapacity`](crate::model::ConsumedCapacity).
    pub fn builder() -> crate::model::consumed_capacity::Builder  {
        crate::model::consumed_capacity::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct Capacity  {
    #[allow(missing_docs)] // documentation missing in model
    pub read_capacity_units: ::std::option::Option<f64>,
    #[allow(missing_docs)] // documentation missing in model
    pub write_capacity_units: ::std::option::Option<f64>,
    #[allow(missing_docs)] // documentation missing in model
    pub capacity_units: ::std::option::Option<f64>,
}
impl  Capacity  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn read_capacity_units(&self) -> ::std::option::Option<f64> {
        self.read_capacity_units
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn write_capacity_units(&self) -> ::std::option::Option<f64> {
        self.write_capacity_units
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn capacity_units(&self) -> ::std::option::Option<f64> {
        self.capacity_units
    }
}
impl  Capacity  {
    /// Creates a new builder-style object to manufacture [`Capacity`](crate::model::Capacity).
    pub fn builder() -> crate::model::capacity::Builder  {
        crate::model::capacity::Builder::default()
    }
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum ConditionalOperator {
    #[allow(missing_docs)] // documentation missing in model
    And,
    #[allow(missing_docs)] // documentation missing in model
    Or,
}
/// See [`ConditionalOperator`](crate::model::ConditionalOperator).
pub mod conditional_operator {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#ConditionalOperator' failed to satisfy constraint: Member must satisfy enum value set: [AND, OR]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [AND, OR]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for ConditionalOperator {
                    type Error = crate::model::conditional_operator::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "AND" => Ok(ConditionalOperator::And),
"OR" => Ok(ConditionalOperator::Or),
                            _ => Err(crate::model::conditional_operator::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for ConditionalOperator {
                    type Error = crate::model::conditional_operator::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for ConditionalOperator {
                    type Err = crate::model::conditional_operator::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl ConditionalOperator {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    ConditionalOperator::And => "AND",
    ConditionalOperator::Or => "OR",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["AND", "OR"]
                }
            }
impl ::std::convert::AsRef<str> for ConditionalOperator {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for ConditionalOperator  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::ConditionalOperator> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum ReturnItemCollectionMetrics {
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Size,
}
/// See [`ReturnItemCollectionMetrics`](crate::model::ReturnItemCollectionMetrics).
pub mod return_item_collection_metrics {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#ReturnItemCollectionMetrics' failed to satisfy constraint: Member must satisfy enum value set: [SIZE, NONE]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [SIZE, NONE]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for ReturnItemCollectionMetrics {
                    type Error = crate::model::return_item_collection_metrics::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "NONE" => Ok(ReturnItemCollectionMetrics::None),
"SIZE" => Ok(ReturnItemCollectionMetrics::Size),
                            _ => Err(crate::model::return_item_collection_metrics::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for ReturnItemCollectionMetrics {
                    type Error = crate::model::return_item_collection_metrics::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for ReturnItemCollectionMetrics {
                    type Err = crate::model::return_item_collection_metrics::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl ReturnItemCollectionMetrics {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    ReturnItemCollectionMetrics::None => "NONE",
    ReturnItemCollectionMetrics::Size => "SIZE",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["NONE", "SIZE"]
                }
            }
impl ::std::convert::AsRef<str> for ReturnItemCollectionMetrics {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for ReturnItemCollectionMetrics  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::ReturnItemCollectionMetrics> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum ReturnConsumedCapacity {
    #[allow(missing_docs)] // documentation missing in model
    Indexes,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    Total,
}
/// See [`ReturnConsumedCapacity`](crate::model::ReturnConsumedCapacity).
pub mod return_consumed_capacity {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#ReturnConsumedCapacity' failed to satisfy constraint: Member must satisfy enum value set: [INDEXES, TOTAL, NONE]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [INDEXES, TOTAL, NONE]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for ReturnConsumedCapacity {
                    type Error = crate::model::return_consumed_capacity::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "INDEXES" => Ok(ReturnConsumedCapacity::Indexes),
"NONE" => Ok(ReturnConsumedCapacity::None),
"TOTAL" => Ok(ReturnConsumedCapacity::Total),
                            _ => Err(crate::model::return_consumed_capacity::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for ReturnConsumedCapacity {
                    type Error = crate::model::return_consumed_capacity::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for ReturnConsumedCapacity {
                    type Err = crate::model::return_consumed_capacity::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl ReturnConsumedCapacity {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    ReturnConsumedCapacity::Indexes => "INDEXES",
    ReturnConsumedCapacity::None => "NONE",
    ReturnConsumedCapacity::Total => "TOTAL",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["INDEXES", "NONE", "TOTAL"]
                }
            }
impl ::std::convert::AsRef<str> for ReturnConsumedCapacity {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for ReturnConsumedCapacity  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::ReturnConsumedCapacity> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum ReturnValue {
    #[allow(missing_docs)] // documentation missing in model
    AllNew,
    #[allow(missing_docs)] // documentation missing in model
    AllOld,
    #[allow(missing_docs)] // documentation missing in model
    None,
    #[allow(missing_docs)] // documentation missing in model
    UpdatedNew,
    #[allow(missing_docs)] // documentation missing in model
    UpdatedOld,
}
/// See [`ReturnValue`](crate::model::ReturnValue).
pub mod return_value {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#ReturnValue' failed to satisfy constraint: Member must satisfy enum value set: [NONE, ALL_OLD, UPDATED_OLD, ALL_NEW, UPDATED_NEW]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [NONE, ALL_OLD, UPDATED_OLD, ALL_NEW, UPDATED_NEW]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for ReturnValue {
                    type Error = crate::model::return_value::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "ALL_NEW" => Ok(ReturnValue::AllNew),
"ALL_OLD" => Ok(ReturnValue::AllOld),
"NONE" => Ok(ReturnValue::None),
"UPDATED_NEW" => Ok(ReturnValue::UpdatedNew),
"UPDATED_OLD" => Ok(ReturnValue::UpdatedOld),
                            _ => Err(crate::model::return_value::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for ReturnValue {
                    type Error = crate::model::return_value::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for ReturnValue {
                    type Err = crate::model::return_value::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl ReturnValue {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    ReturnValue::AllNew => "ALL_NEW",
    ReturnValue::AllOld => "ALL_OLD",
    ReturnValue::None => "NONE",
    ReturnValue::UpdatedNew => "UPDATED_NEW",
    ReturnValue::UpdatedOld => "UPDATED_OLD",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["ALL_NEW", "ALL_OLD", "NONE", "UPDATED_NEW", "UPDATED_OLD"]
                }
            }
impl ::std::convert::AsRef<str> for ReturnValue {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for ReturnValue  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::ReturnValue> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }



#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ExpectedAttributeValue  {
    #[allow(missing_docs)] // documentation missing in model
    pub value: ::std::option::Option<crate::model::AttributeValue>,
    #[allow(missing_docs)] // documentation missing in model
    pub exists: ::std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub comparison_operator: ::std::option::Option<crate::model::ComparisonOperator>,
    #[allow(missing_docs)] // documentation missing in model
    pub attribute_value_list: ::std::option::Option<::std::vec::Vec::<crate::model::AttributeValue>>,
}
impl  ExpectedAttributeValue  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn value(&self) -> ::std::option::Option<&crate::model::AttributeValue> {
        self.value.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn exists(&self) -> ::std::option::Option<bool> {
        self.exists
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn comparison_operator(&self) -> ::std::option::Option<&crate::model::ComparisonOperator> {
        self.comparison_operator.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn attribute_value_list(&self) -> ::std::option::Option<&[crate::model::AttributeValue]> {
        self.attribute_value_list.as_deref()
    }
}
impl  ExpectedAttributeValue  {
    /// Creates a new builder-style object to manufacture [`ExpectedAttributeValue`](crate::model::ExpectedAttributeValue).
    pub fn builder() -> crate::model::expected_attribute_value::Builder  {
        crate::model::expected_attribute_value::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::model::ExpectedAttributeValue {
                type Unconstrained = crate::model::expected_attribute_value::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::Ord, ::std::cmp::PartialEq, ::std::cmp::PartialOrd, ::std::fmt::Debug, ::std::hash::Hash)]
pub enum ComparisonOperator {
    #[allow(missing_docs)] // documentation missing in model
    BeginsWith,
    #[allow(missing_docs)] // documentation missing in model
    Between,
    #[allow(missing_docs)] // documentation missing in model
    Contains,
    #[allow(missing_docs)] // documentation missing in model
    Eq,
    #[allow(missing_docs)] // documentation missing in model
    Ge,
    #[allow(missing_docs)] // documentation missing in model
    Gt,
    #[allow(missing_docs)] // documentation missing in model
    In,
    #[allow(missing_docs)] // documentation missing in model
    Le,
    #[allow(missing_docs)] // documentation missing in model
    Lt,
    #[allow(missing_docs)] // documentation missing in model
    Ne,
    #[allow(missing_docs)] // documentation missing in model
    NotContains,
    #[allow(missing_docs)] // documentation missing in model
    NotNull,
    #[allow(missing_docs)] // documentation missing in model
    Null,
}
/// See [`ComparisonOperator`](crate::model::ComparisonOperator).
pub mod comparison_operator {
    #[derive(Debug, PartialEq)]
                    pub struct ConstraintViolation(pub(crate) ::std::string::String);
    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            write!(f, r#"Value provided for 'com.amazonaws.dynamodb#ComparisonOperator' failed to satisfy constraint: Member must satisfy enum value set: [EQ, NE, IN, LE, LT, GE, GT, BETWEEN, NOT_NULL, NULL, CONTAINS, NOT_CONTAINS, BEGINS_WITH]"#)
                        }
                    }
    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                        crate::model::ValidationExceptionField {
                            message: format!(r#"Value at '{}' failed to satisfy constraint: Member must satisfy enum value set: [EQ, NE, IN, LE, LT, GE, GT, BETWEEN, NOT_NULL, NULL, CONTAINS, NOT_CONTAINS, BEGINS_WITH]"#, &path),
                            path,
                        }
                    }
                        }
    
    
}
impl ::std::convert::TryFrom<&str> for ComparisonOperator {
                    type Error = crate::model::comparison_operator::ConstraintViolation;
                    fn try_from(s: &str) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<&str>>::Error> {
                        match s {
                            "BEGINS_WITH" => Ok(ComparisonOperator::BeginsWith),
"BETWEEN" => Ok(ComparisonOperator::Between),
"CONTAINS" => Ok(ComparisonOperator::Contains),
"EQ" => Ok(ComparisonOperator::Eq),
"GE" => Ok(ComparisonOperator::Ge),
"GT" => Ok(ComparisonOperator::Gt),
"IN" => Ok(ComparisonOperator::In),
"LE" => Ok(ComparisonOperator::Le),
"LT" => Ok(ComparisonOperator::Lt),
"NE" => Ok(ComparisonOperator::Ne),
"NOT_CONTAINS" => Ok(ComparisonOperator::NotContains),
"NOT_NULL" => Ok(ComparisonOperator::NotNull),
"NULL" => Ok(ComparisonOperator::Null),
                            _ => Err(crate::model::comparison_operator::ConstraintViolation(s.to_owned()))
                        }
                    }
                }
                impl ::std::convert::TryFrom<::std::string::String> for ComparisonOperator {
                    type Error = crate::model::comparison_operator::ConstraintViolation;
                    fn try_from(s: ::std::string::String) -> ::std::result::Result<Self, <Self as ::std::convert::TryFrom<::std::string::String>>::Error> {
                        s.as_str().try_into()
                    }
                }
impl std::str::FromStr for ComparisonOperator {
                    type Err = crate::model::comparison_operator::ConstraintViolation;
                    fn from_str(s: &str) -> std::result::Result<Self, <Self as std::str::FromStr>::Err> {
                        Self::try_from(s)
                    }
                }
impl ComparisonOperator {
                /// Returns the `&str` value of the enum member.
                pub fn as_str(&self) -> &str {
                    match self {
    ComparisonOperator::BeginsWith => "BEGINS_WITH",
    ComparisonOperator::Between => "BETWEEN",
    ComparisonOperator::Contains => "CONTAINS",
    ComparisonOperator::Eq => "EQ",
    ComparisonOperator::Ge => "GE",
    ComparisonOperator::Gt => "GT",
    ComparisonOperator::In => "IN",
    ComparisonOperator::Le => "LE",
    ComparisonOperator::Lt => "LT",
    ComparisonOperator::Ne => "NE",
    ComparisonOperator::NotContains => "NOT_CONTAINS",
    ComparisonOperator::NotNull => "NOT_NULL",
    ComparisonOperator::Null => "NULL",
}
                }
                /// Returns all the `&str` representations of the enum members.
                pub const fn values() -> &'static [&'static str] {
                    &["BEGINS_WITH", "BETWEEN", "CONTAINS", "EQ", "GE", "GT", "IN", "LE", "LT", "NE", "NOT_CONTAINS", "NOT_NULL", "NULL"]
                }
            }
impl ::std::convert::AsRef<str> for ComparisonOperator {
                fn as_ref(&self) -> &str {
                    self.as_str()
                }
            }
impl crate::constrained::Constrained for ComparisonOperator  {
                type Unconstrained = ::std::string::String;
            }

            impl ::std::convert::From<::std::string::String> for crate::constrained::MaybeConstrained<crate::model::ComparisonOperator> {
                fn from(value: ::std::string::String) -> Self {
                    Self::Unconstrained(value)
                }
            }
/// See [`ValidationExceptionField`](crate::model::ValidationExceptionField).
pub mod validation_exception_field {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `path` was not provided but it is required when building `ValidationExceptionField`.
        MissingPath,
        /// `message` was not provided but it is required when building `ValidationExceptionField`.
        MissingMessage,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingPath => write!(f, "`path` was not provided but it is required when building `ValidationExceptionField`"),
                ConstraintViolation::MissingMessage => write!(f, "`message` was not provided but it is required when building `ValidationExceptionField`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl  ::std::convert::TryFrom<Builder > for crate::model::ValidationExceptionField {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`ValidationExceptionField`](crate::model::ValidationExceptionField).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) path: ::std::option::Option<::std::string::String>,
        pub(crate) message: ::std::option::Option<::std::string::String>,
    }
    impl  Builder  {
        /// A JSONPointer expression to the structure member whose value failed to satisfy the modeled constraints.
        pub fn path(mut self, input: ::std::string::String) -> Self {
            self.path =
                Some(
                    input
                )
            ; self
        }
        /// A detailed description of the validation failure.
        pub fn message(mut self, input: ::std::string::String) -> Self {
            self.message =
                Some(
                    input
                )
            ; self
        }
        /// Consumes the builder and constructs a [`ValidationExceptionField`](crate::model::ValidationExceptionField).
        /// 
        /// The builder fails to construct a [`ValidationExceptionField`](crate::model::ValidationExceptionField) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::ValidationExceptionField , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::ValidationExceptionField , ConstraintViolation> {
            Ok(
                crate::model::ValidationExceptionField {
                    path: self.path
                        .ok_or(ConstraintViolation::MissingPath)?
                    ,
                    message: self.message
                        .ok_or(ConstraintViolation::MissingMessage)?
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`TableDescription`](crate::model::TableDescription).
pub mod table_description {
    
    impl ::std::convert::From<Builder > for crate::model::TableDescription  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`TableDescription`](crate::model::TableDescription).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_definitions: ::std::option::Option<::std::vec::Vec::<crate::model::AttributeDefinition>>,
        pub(crate) table_name: ::std::option::Option<::std::string::String>,
        pub(crate) key_schema: ::std::option::Option<::std::vec::Vec::<crate::model::KeySchemaElement>>,
        pub(crate) table_status: ::std::option::Option<crate::model::TableStatus>,
        pub(crate) creation_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
        pub(crate) provisioned_throughput: ::std::option::Option<crate::model::ProvisionedThroughputDescription>,
        pub(crate) table_size_bytes: ::std::option::Option<i64>,
        pub(crate) item_count: ::std::option::Option<i64>,
        pub(crate) table_arn: ::std::option::Option<::std::string::String>,
        pub(crate) table_id: ::std::option::Option<::std::string::String>,
        pub(crate) billing_mode_summary: ::std::option::Option<crate::model::BillingModeSummary>,
        pub(crate) local_secondary_indexes: ::std::option::Option<::std::vec::Vec::<crate::model::LocalSecondaryIndexDescription>>,
        pub(crate) global_secondary_indexes: ::std::option::Option<::std::vec::Vec::<crate::model::GlobalSecondaryIndexDescription>>,
        pub(crate) stream_specification: ::std::option::Option<crate::model::StreamSpecification>,
        pub(crate) latest_stream_label: ::std::option::Option<::std::string::String>,
        pub(crate) latest_stream_arn: ::std::option::Option<::std::string::String>,
        pub(crate) global_table_version: ::std::option::Option<::std::string::String>,
        pub(crate) replicas: ::std::option::Option<::std::vec::Vec::<crate::model::ReplicaDescription>>,
        pub(crate) restore_summary: ::std::option::Option<crate::model::RestoreSummary>,
        pub(crate) sse_description: ::std::option::Option<crate::model::SseDescription>,
        pub(crate) archival_summary: ::std::option::Option<crate::model::ArchivalSummary>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn attribute_definitions(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::model::AttributeDefinition>>) -> Self {
            self.attribute_definitions =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.table_name =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn key_schema(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::model::KeySchemaElement>>) -> Self {
            self.key_schema =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_status(mut self, input: ::std::option::Option<crate::model::TableStatus>) -> Self {
            self.table_status =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn creation_date_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
            self.creation_date_time =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn provisioned_throughput(mut self, input: ::std::option::Option<crate::model::ProvisionedThroughputDescription>) -> Self {
            self.provisioned_throughput =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_size_bytes(mut self, input: ::std::option::Option<i64>) -> Self {
            self.table_size_bytes =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn item_count(mut self, input: ::std::option::Option<i64>) -> Self {
            self.item_count =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.table_arn =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.table_id =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn billing_mode_summary(mut self, input: ::std::option::Option<crate::model::BillingModeSummary>) -> Self {
            self.billing_mode_summary =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn local_secondary_indexes(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::model::LocalSecondaryIndexDescription>>) -> Self {
            self.local_secondary_indexes =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn global_secondary_indexes(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::model::GlobalSecondaryIndexDescription>>) -> Self {
            self.global_secondary_indexes =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn stream_specification(mut self, input: ::std::option::Option<crate::model::StreamSpecification>) -> Self {
            self.stream_specification =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn latest_stream_label(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.latest_stream_label =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn latest_stream_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.latest_stream_arn =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn global_table_version(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.global_table_version =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn replicas(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::model::ReplicaDescription>>) -> Self {
            self.replicas =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn restore_summary(mut self, input: ::std::option::Option<crate::model::RestoreSummary>) -> Self {
            self.restore_summary =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn sse_description(mut self, input: ::std::option::Option<crate::model::SseDescription>) -> Self {
            self.sse_description =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn archival_summary(mut self, input: ::std::option::Option<crate::model::ArchivalSummary>) -> Self {
            self.archival_summary =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`TableDescription`](crate::model::TableDescription).
        pub fn build(self) -> crate::model::TableDescription {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::TableDescription {
            crate::model::TableDescription {
                attribute_definitions: self.attribute_definitions
                ,
                table_name: self.table_name
                ,
                key_schema: self.key_schema
                ,
                table_status: self.table_status
                ,
                creation_date_time: self.creation_date_time
                ,
                provisioned_throughput: self.provisioned_throughput
                ,
                table_size_bytes: self.table_size_bytes
                ,
                item_count: self.item_count
                ,
                table_arn: self.table_arn
                ,
                table_id: self.table_id
                ,
                billing_mode_summary: self.billing_mode_summary
                ,
                local_secondary_indexes: self.local_secondary_indexes
                ,
                global_secondary_indexes: self.global_secondary_indexes
                ,
                stream_specification: self.stream_specification
                ,
                latest_stream_label: self.latest_stream_label
                ,
                latest_stream_arn: self.latest_stream_arn
                ,
                global_table_version: self.global_table_version
                ,
                replicas: self.replicas
                ,
                restore_summary: self.restore_summary
                ,
                sse_description: self.sse_description
                ,
                archival_summary: self.archival_summary
                ,
            }
        }
    }
    
    
    
    
}
/// See [`ArchivalSummary`](crate::model::ArchivalSummary).
pub mod archival_summary {
    
    impl ::std::convert::From<Builder > for crate::model::ArchivalSummary  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`ArchivalSummary`](crate::model::ArchivalSummary).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) archival_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
        pub(crate) archival_reason: ::std::option::Option<::std::string::String>,
        pub(crate) archival_backup_arn: ::std::option::Option<::std::string::String>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn archival_date_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
            self.archival_date_time =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn archival_reason(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.archival_reason =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn archival_backup_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.archival_backup_arn =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`ArchivalSummary`](crate::model::ArchivalSummary).
        pub fn build(self) -> crate::model::ArchivalSummary {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::ArchivalSummary {
            crate::model::ArchivalSummary {
                archival_date_time: self.archival_date_time
                ,
                archival_reason: self.archival_reason
                ,
                archival_backup_arn: self.archival_backup_arn
                ,
            }
        }
    }
    
    
    
    
}
/// See [`SseDescription`](crate::model::SseDescription).
pub mod sse_description {
    
    impl ::std::convert::From<Builder > for crate::model::SseDescription  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`SseDescription`](crate::model::SseDescription).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: ::std::option::Option<crate::model::SSEStatus>,
        pub(crate) sse_type: ::std::option::Option<crate::model::SSEType>,
        pub(crate) kms_master_key_arn: ::std::option::Option<::std::string::String>,
        pub(crate) inaccessible_encryption_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn status(mut self, input: ::std::option::Option<crate::model::SSEStatus>) -> Self {
            self.status =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn sse_type(mut self, input: ::std::option::Option<crate::model::SSEType>) -> Self {
            self.sse_type =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn kms_master_key_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.kms_master_key_arn =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn inaccessible_encryption_date_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
            self.inaccessible_encryption_date_time =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`SseDescription`](crate::model::SseDescription).
        pub fn build(self) -> crate::model::SseDescription {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::SseDescription {
            crate::model::SseDescription {
                status: self.status
                ,
                sse_type: self.sse_type
                ,
                kms_master_key_arn: self.kms_master_key_arn
                ,
                inaccessible_encryption_date_time: self.inaccessible_encryption_date_time
                ,
            }
        }
    }
    
    
    
    
}
/// See [`RestoreSummary`](crate::model::RestoreSummary).
pub mod restore_summary {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `restore_date_time` was not provided but it is required when building `RestoreSummary`.
        MissingRestoreDateTime,
        /// `restore_in_progress` was not provided but it is required when building `RestoreSummary`.
        MissingRestoreInProgress,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingRestoreDateTime => write!(f, "`restore_date_time` was not provided but it is required when building `RestoreSummary`"),
                ConstraintViolation::MissingRestoreInProgress => write!(f, "`restore_in_progress` was not provided but it is required when building `RestoreSummary`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl  ::std::convert::TryFrom<Builder > for crate::model::RestoreSummary {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`RestoreSummary`](crate::model::RestoreSummary).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) source_backup_arn: ::std::option::Option<::std::string::String>,
        pub(crate) source_table_arn: ::std::option::Option<::std::string::String>,
        pub(crate) restore_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
        pub(crate) restore_in_progress: ::std::option::Option<bool>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn source_backup_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.source_backup_arn =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn source_table_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.source_table_arn =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn restore_date_time(mut self, input: ::aws_smithy_types::DateTime) -> Self {
            self.restore_date_time =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn restore_in_progress(mut self, input: bool) -> Self {
            self.restore_in_progress =
                Some(
                    input
                )
            ; self
        }
        /// Consumes the builder and constructs a [`RestoreSummary`](crate::model::RestoreSummary).
        /// 
        /// The builder fails to construct a [`RestoreSummary`](crate::model::RestoreSummary) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::RestoreSummary , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::RestoreSummary , ConstraintViolation> {
            Ok(
                crate::model::RestoreSummary {
                    source_backup_arn: self.source_backup_arn
                    ,
                    source_table_arn: self.source_table_arn
                    ,
                    restore_date_time: self.restore_date_time
                        .ok_or(ConstraintViolation::MissingRestoreDateTime)?
                    ,
                    restore_in_progress: self.restore_in_progress
                        .ok_or(ConstraintViolation::MissingRestoreInProgress)?
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`ReplicaDescription`](crate::model::ReplicaDescription).
pub mod replica_description {
    
    impl ::std::convert::From<Builder > for crate::model::ReplicaDescription  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`ReplicaDescription`](crate::model::ReplicaDescription).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) region_name: ::std::option::Option<::std::string::String>,
        pub(crate) replica_status: ::std::option::Option<crate::model::ReplicaStatus>,
        pub(crate) replica_status_description: ::std::option::Option<::std::string::String>,
        pub(crate) replica_status_percent_progress: ::std::option::Option<::std::string::String>,
        pub(crate) kms_master_key_id: ::std::option::Option<::std::string::String>,
        pub(crate) provisioned_throughput_override: ::std::option::Option<crate::model::ProvisionedThroughputOverride>,
        pub(crate) global_secondary_indexes: ::std::option::Option<::std::vec::Vec::<crate::model::ReplicaGlobalSecondaryIndexDescription>>,
        pub(crate) replica_inaccessible_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn region_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.region_name =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn replica_status(mut self, input: ::std::option::Option<crate::model::ReplicaStatus>) -> Self {
            self.replica_status =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn replica_status_description(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.replica_status_description =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn replica_status_percent_progress(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.replica_status_percent_progress =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn kms_master_key_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.kms_master_key_id =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn provisioned_throughput_override(mut self, input: ::std::option::Option<crate::model::ProvisionedThroughputOverride>) -> Self {
            self.provisioned_throughput_override =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn global_secondary_indexes(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::model::ReplicaGlobalSecondaryIndexDescription>>) -> Self {
            self.global_secondary_indexes =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn replica_inaccessible_date_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
            self.replica_inaccessible_date_time =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`ReplicaDescription`](crate::model::ReplicaDescription).
        pub fn build(self) -> crate::model::ReplicaDescription {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::ReplicaDescription {
            crate::model::ReplicaDescription {
                region_name: self.region_name
                ,
                replica_status: self.replica_status
                ,
                replica_status_description: self.replica_status_description
                ,
                replica_status_percent_progress: self.replica_status_percent_progress
                ,
                kms_master_key_id: self.kms_master_key_id
                ,
                provisioned_throughput_override: self.provisioned_throughput_override
                ,
                global_secondary_indexes: self.global_secondary_indexes
                ,
                replica_inaccessible_date_time: self.replica_inaccessible_date_time
                ,
            }
        }
    }
    
    
    
    
}
/// See [`ReplicaGlobalSecondaryIndexDescription`](crate::model::ReplicaGlobalSecondaryIndexDescription).
pub mod replica_global_secondary_index_description {
    
    impl ::std::convert::From<Builder > for crate::model::ReplicaGlobalSecondaryIndexDescription  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`ReplicaGlobalSecondaryIndexDescription`](crate::model::ReplicaGlobalSecondaryIndexDescription).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: ::std::option::Option<::std::string::String>,
        pub(crate) provisioned_throughput_override: ::std::option::Option<crate::model::ProvisionedThroughputOverride>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn index_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.index_name =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn provisioned_throughput_override(mut self, input: ::std::option::Option<crate::model::ProvisionedThroughputOverride>) -> Self {
            self.provisioned_throughput_override =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`ReplicaGlobalSecondaryIndexDescription`](crate::model::ReplicaGlobalSecondaryIndexDescription).
        pub fn build(self) -> crate::model::ReplicaGlobalSecondaryIndexDescription {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::ReplicaGlobalSecondaryIndexDescription {
            crate::model::ReplicaGlobalSecondaryIndexDescription {
                index_name: self.index_name
                ,
                provisioned_throughput_override: self.provisioned_throughput_override
                ,
            }
        }
    }
    
    
    
    
}
/// See [`ProvisionedThroughputOverride`](crate::model::ProvisionedThroughputOverride).
pub mod provisioned_throughput_override {
    
    impl ::std::convert::From<Builder > for crate::model::ProvisionedThroughputOverride  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`ProvisionedThroughputOverride`](crate::model::ProvisionedThroughputOverride).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_capacity_units: ::std::option::Option<i64>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn read_capacity_units(mut self, input: ::std::option::Option<i64>) -> Self {
            self.read_capacity_units =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughputOverride`](crate::model::ProvisionedThroughputOverride).
        pub fn build(self) -> crate::model::ProvisionedThroughputOverride {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::ProvisionedThroughputOverride {
            crate::model::ProvisionedThroughputOverride {
                read_capacity_units: self.read_capacity_units
                ,
            }
        }
    }
    
    
    
    
}
/// See [`StreamSpecification`](crate::model::StreamSpecification).
pub mod stream_specification {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `stream_enabled` was not provided but it is required when building `StreamSpecification`.
        MissingStreamEnabled,
        /// Constraint violation occurred building member `stream_view_type` when building `StreamSpecification`.
        #[doc(hidden)]
        StreamViewType(crate::model::stream_view_type::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingStreamEnabled => write!(f, "`stream_enabled` was not provided but it is required when building `StreamSpecification`"),
                ConstraintViolation::StreamViewType(_) => write!(f, "constraint violation occurred building member `stream_view_type` when building `StreamSpecification`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::MissingStreamEnabled => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/StreamEnabled' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/StreamEnabled",
                                            },
            ConstraintViolation::StreamViewType(inner) => inner.as_validation_exception_field(path + "/StreamViewType"),
        }
    }
                }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::model::StreamSpecification> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::model::StreamSpecification {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`StreamSpecification`](crate::model::StreamSpecification).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) stream_enabled: ::std::option::Option<bool>,
        pub(crate) stream_view_type: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::StreamViewType>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn stream_enabled(mut self, input: bool) -> Self {
            self.stream_enabled =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_stream_enabled(mut self, input: impl ::std::convert::Into<bool>) -> Self {
            self.stream_enabled = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn stream_view_type(mut self, input: ::std::option::Option<crate::model::StreamViewType>) -> Self {
            self.stream_view_type =
                input.map(#[allow(clippy::redundant_closure)] |v|
                    crate::constrained::MaybeConstrained::Constrained(v)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_stream_view_type(mut self, input: Option<impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::StreamViewType>>>) -> Self {
            self.stream_view_type = input.map(|v| v.into());
                            self
        }
        /// Consumes the builder and constructs a [`StreamSpecification`](crate::model::StreamSpecification).
        /// 
        /// The builder fails to construct a [`StreamSpecification`](crate::model::StreamSpecification) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::StreamSpecification , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::StreamSpecification , ConstraintViolation> {
            Ok(
                crate::model::StreamSpecification {
                    stream_enabled: self.stream_enabled
                        .ok_or(ConstraintViolation::MissingStreamEnabled)?
                    ,
                    stream_view_type: self.stream_view_type
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::StreamViewType)
                                    )
                                    .transpose()?
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`GlobalSecondaryIndexDescription`](crate::model::GlobalSecondaryIndexDescription).
pub mod global_secondary_index_description {
    
    impl ::std::convert::From<Builder > for crate::model::GlobalSecondaryIndexDescription  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`GlobalSecondaryIndexDescription`](crate::model::GlobalSecondaryIndexDescription).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: ::std::option::Option<::std::string::String>,
        pub(crate) key_schema: ::std::option::Option<::std::vec::Vec::<crate::model::KeySchemaElement>>,
        pub(crate) projection: ::std::option::Option<crate::model::Projection>,
        pub(crate) index_status: ::std::option::Option<crate::model::IndexStatus>,
        pub(crate) backfilling: ::std::option::Option<bool>,
        pub(crate) provisioned_throughput: ::std::option::Option<crate::model::ProvisionedThroughputDescription>,
        pub(crate) index_size_bytes: ::std::option::Option<i64>,
        pub(crate) item_count: ::std::option::Option<i64>,
        pub(crate) index_arn: ::std::option::Option<::std::string::String>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn index_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.index_name =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn key_schema(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::model::KeySchemaElement>>) -> Self {
            self.key_schema =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn projection(mut self, input: ::std::option::Option<crate::model::Projection>) -> Self {
            self.projection =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn index_status(mut self, input: ::std::option::Option<crate::model::IndexStatus>) -> Self {
            self.index_status =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn backfilling(mut self, input: ::std::option::Option<bool>) -> Self {
            self.backfilling =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn provisioned_throughput(mut self, input: ::std::option::Option<crate::model::ProvisionedThroughputDescription>) -> Self {
            self.provisioned_throughput =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn index_size_bytes(mut self, input: ::std::option::Option<i64>) -> Self {
            self.index_size_bytes =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn item_count(mut self, input: ::std::option::Option<i64>) -> Self {
            self.item_count =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn index_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.index_arn =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`GlobalSecondaryIndexDescription`](crate::model::GlobalSecondaryIndexDescription).
        pub fn build(self) -> crate::model::GlobalSecondaryIndexDescription {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::GlobalSecondaryIndexDescription {
            crate::model::GlobalSecondaryIndexDescription {
                index_name: self.index_name
                ,
                key_schema: self.key_schema
                ,
                projection: self.projection
                ,
                index_status: self.index_status
                ,
                backfilling: self.backfilling
                ,
                provisioned_throughput: self.provisioned_throughput
                ,
                index_size_bytes: self.index_size_bytes
                ,
                item_count: self.item_count
                ,
                index_arn: self.index_arn
                ,
            }
        }
    }
    
    
    
    
}
/// See [`ProvisionedThroughputDescription`](crate::model::ProvisionedThroughputDescription).
pub mod provisioned_throughput_description {
    
    impl ::std::convert::From<Builder > for crate::model::ProvisionedThroughputDescription  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`ProvisionedThroughputDescription`](crate::model::ProvisionedThroughputDescription).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) last_increase_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
        pub(crate) last_decrease_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
        pub(crate) number_of_decreases_today: ::std::option::Option<i64>,
        pub(crate) read_capacity_units: ::std::option::Option<i64>,
        pub(crate) write_capacity_units: ::std::option::Option<i64>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn last_increase_date_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
            self.last_increase_date_time =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn last_decrease_date_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
            self.last_decrease_date_time =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn number_of_decreases_today(mut self, input: ::std::option::Option<i64>) -> Self {
            self.number_of_decreases_today =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn read_capacity_units(mut self, input: ::std::option::Option<i64>) -> Self {
            self.read_capacity_units =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn write_capacity_units(mut self, input: ::std::option::Option<i64>) -> Self {
            self.write_capacity_units =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughputDescription`](crate::model::ProvisionedThroughputDescription).
        pub fn build(self) -> crate::model::ProvisionedThroughputDescription {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::ProvisionedThroughputDescription {
            crate::model::ProvisionedThroughputDescription {
                last_increase_date_time: self.last_increase_date_time
                ,
                last_decrease_date_time: self.last_decrease_date_time
                ,
                number_of_decreases_today: self.number_of_decreases_today
                ,
                read_capacity_units: self.read_capacity_units
                ,
                write_capacity_units: self.write_capacity_units
                ,
            }
        }
    }
    
    
    
    
}
/// See [`Projection`](crate::model::Projection).
pub mod projection {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// Constraint violation occurred building member `projection_type` when building `Projection`.
        #[doc(hidden)]
        ProjectionType(crate::model::projection_type::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::ProjectionType(_) => write!(f, "constraint violation occurred building member `projection_type` when building `Projection`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::ProjectionType(inner) => inner.as_validation_exception_field(path + "/ProjectionType"),
        }
    }
                }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::model::Projection> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::model::Projection {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`Projection`](crate::model::Projection).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) projection_type: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ProjectionType>>,
        pub(crate) non_key_attributes: ::std::option::Option<::std::vec::Vec::<::std::string::String>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn projection_type(mut self, input: ::std::option::Option<crate::model::ProjectionType>) -> Self {
            self.projection_type =
                input.map(#[allow(clippy::redundant_closure)] |v|
                    crate::constrained::MaybeConstrained::Constrained(v)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_projection_type(mut self, input: Option<impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::ProjectionType>>>) -> Self {
            self.projection_type = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn non_key_attributes(mut self, input: ::std::option::Option<::std::vec::Vec::<::std::string::String>>) -> Self {
            self.non_key_attributes =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_non_key_attributes(mut self, input: Option<impl ::std::convert::Into<::std::vec::Vec::<::std::string::String>>>) -> Self {
            self.non_key_attributes = input.map(|v| v.into());
                            self
        }
        /// Consumes the builder and constructs a [`Projection`](crate::model::Projection).
        /// 
        /// The builder fails to construct a [`Projection`](crate::model::Projection) if a [`ConstraintViolation`] occurs.
        /// 
        pub fn build(self) -> Result<crate::model::Projection , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::Projection , ConstraintViolation> {
            Ok(
                crate::model::Projection {
                    projection_type: self.projection_type
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::ProjectionType)
                                    )
                                    .transpose()?
                    ,
                    non_key_attributes: self.non_key_attributes
                    ,
                }
            )
        }
    }
    
    
    
    
}
pub mod key_schema {
    
    #[allow(clippy::enum_variant_names)]
                    #[derive(Debug, PartialEq)]
                    pub enum ConstraintViolation {
                        /// Constraint violation error when an element doesn't satisfy its own constraints.
                            /// The first component of the tuple is the index in the collection where the
                            /// first constraint violation was found.
                            #[doc(hidden)]
                            Member(usize, crate::model::key_schema_element::ConstraintViolation)
                    }
                    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            let message = match self {
                                Self::Member(index, failing_member) => format!("Value at index {index} failed to satisfy constraint. {}",
                           failing_member)
                            };
                            write!(f, "{message}")
                        }
                    }
                    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                    match self {
                        Self::Member(index, member_constraint_violation) =>
                        member_constraint_violation.as_validation_exception_field(path + "/" + &index.to_string())
                    }
                }
                        }
    
    
    
    
}
/// See [`KeySchemaElement`](crate::model::KeySchemaElement).
pub mod key_schema_element {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `attribute_name` was not provided but it is required when building `KeySchemaElement`.
        MissingAttributeName,
        /// `key_type` was not provided but it is required when building `KeySchemaElement`.
        MissingKeyType,
        /// Constraint violation occurred building member `key_type` when building `KeySchemaElement`.
        #[doc(hidden)]
        KeyType(crate::model::key_type::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingAttributeName => write!(f, "`attribute_name` was not provided but it is required when building `KeySchemaElement`"),
                ConstraintViolation::MissingKeyType => write!(f, "`key_type` was not provided but it is required when building `KeySchemaElement`"),
                ConstraintViolation::KeyType(_) => write!(f, "constraint violation occurred building member `key_type` when building `KeySchemaElement`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::MissingAttributeName => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/AttributeName' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/AttributeName",
                                            },
            ConstraintViolation::MissingKeyType => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/KeyType' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/KeyType",
                                            },
            ConstraintViolation::KeyType(inner) => inner.as_validation_exception_field(path + "/KeyType"),
        }
    }
                }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::model::KeySchemaElement> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::model::KeySchemaElement {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`KeySchemaElement`](crate::model::KeySchemaElement).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: ::std::option::Option<::std::string::String>,
        pub(crate) key_type: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::KeyType>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn attribute_name(mut self, input: ::std::string::String) -> Self {
            self.attribute_name =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_attribute_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn key_type(mut self, input: crate::model::KeyType) -> Self {
            self.key_type =
                Some(
                    crate::constrained::MaybeConstrained::Constrained(input)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_key_type(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::KeyType>>) -> Self {
            self.key_type = Some(input.into());
                            self
        }
        /// Consumes the builder and constructs a [`KeySchemaElement`](crate::model::KeySchemaElement).
        /// 
        /// The builder fails to construct a [`KeySchemaElement`](crate::model::KeySchemaElement) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::KeySchemaElement , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::KeySchemaElement , ConstraintViolation> {
            Ok(
                crate::model::KeySchemaElement {
                    attribute_name: self.attribute_name
                        .ok_or(ConstraintViolation::MissingAttributeName)?
                    ,
                    key_type: self.key_type
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::KeyType)
                                    )
                                    .transpose()?
                        .ok_or(ConstraintViolation::MissingKeyType)?
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`LocalSecondaryIndexDescription`](crate::model::LocalSecondaryIndexDescription).
pub mod local_secondary_index_description {
    
    impl ::std::convert::From<Builder > for crate::model::LocalSecondaryIndexDescription  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`LocalSecondaryIndexDescription`](crate::model::LocalSecondaryIndexDescription).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: ::std::option::Option<::std::string::String>,
        pub(crate) key_schema: ::std::option::Option<::std::vec::Vec::<crate::model::KeySchemaElement>>,
        pub(crate) projection: ::std::option::Option<crate::model::Projection>,
        pub(crate) index_size_bytes: ::std::option::Option<i64>,
        pub(crate) item_count: ::std::option::Option<i64>,
        pub(crate) index_arn: ::std::option::Option<::std::string::String>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn index_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.index_name =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn key_schema(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::model::KeySchemaElement>>) -> Self {
            self.key_schema =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn projection(mut self, input: ::std::option::Option<crate::model::Projection>) -> Self {
            self.projection =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn index_size_bytes(mut self, input: ::std::option::Option<i64>) -> Self {
            self.index_size_bytes =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn item_count(mut self, input: ::std::option::Option<i64>) -> Self {
            self.item_count =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn index_arn(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.index_arn =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`LocalSecondaryIndexDescription`](crate::model::LocalSecondaryIndexDescription).
        pub fn build(self) -> crate::model::LocalSecondaryIndexDescription {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::LocalSecondaryIndexDescription {
            crate::model::LocalSecondaryIndexDescription {
                index_name: self.index_name
                ,
                key_schema: self.key_schema
                ,
                projection: self.projection
                ,
                index_size_bytes: self.index_size_bytes
                ,
                item_count: self.item_count
                ,
                index_arn: self.index_arn
                ,
            }
        }
    }
    
    
    
    
}
/// See [`BillingModeSummary`](crate::model::BillingModeSummary).
pub mod billing_mode_summary {
    
    impl ::std::convert::From<Builder > for crate::model::BillingModeSummary  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`BillingModeSummary`](crate::model::BillingModeSummary).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) billing_mode: ::std::option::Option<crate::model::BillingMode>,
        pub(crate) last_update_to_pay_per_request_date_time: ::std::option::Option<::aws_smithy_types::DateTime>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn billing_mode(mut self, input: ::std::option::Option<crate::model::BillingMode>) -> Self {
            self.billing_mode =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn last_update_to_pay_per_request_date_time(mut self, input: ::std::option::Option<::aws_smithy_types::DateTime>) -> Self {
            self.last_update_to_pay_per_request_date_time =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`BillingModeSummary`](crate::model::BillingModeSummary).
        pub fn build(self) -> crate::model::BillingModeSummary {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::BillingModeSummary {
            crate::model::BillingModeSummary {
                billing_mode: self.billing_mode
                ,
                last_update_to_pay_per_request_date_time: self.last_update_to_pay_per_request_date_time
                ,
            }
        }
    }
    
    
    
    
}
pub mod attribute_definitions {
    
    #[allow(clippy::enum_variant_names)]
                    #[derive(Debug, PartialEq)]
                    pub enum ConstraintViolation {
                        /// Constraint violation error when an element doesn't satisfy its own constraints.
                            /// The first component of the tuple is the index in the collection where the
                            /// first constraint violation was found.
                            #[doc(hidden)]
                            Member(usize, crate::model::attribute_definition::ConstraintViolation)
                    }
                    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            let message = match self {
                                Self::Member(index, failing_member) => format!("Value at index {index} failed to satisfy constraint. {}",
                           failing_member)
                            };
                            write!(f, "{message}")
                        }
                    }
                    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                    match self {
                        Self::Member(index, member_constraint_violation) =>
                        member_constraint_violation.as_validation_exception_field(path + "/" + &index.to_string())
                    }
                }
                        }
    
    
    
    
}
/// See [`AttributeDefinition`](crate::model::AttributeDefinition).
pub mod attribute_definition {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `attribute_name` was not provided but it is required when building `AttributeDefinition`.
        MissingAttributeName,
        /// `attribute_type` was not provided but it is required when building `AttributeDefinition`.
        MissingAttributeType,
        /// Constraint violation occurred building member `attribute_type` when building `AttributeDefinition`.
        #[doc(hidden)]
        AttributeType(crate::model::scalar_attribute_type::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingAttributeName => write!(f, "`attribute_name` was not provided but it is required when building `AttributeDefinition`"),
                ConstraintViolation::MissingAttributeType => write!(f, "`attribute_type` was not provided but it is required when building `AttributeDefinition`"),
                ConstraintViolation::AttributeType(_) => write!(f, "constraint violation occurred building member `attribute_type` when building `AttributeDefinition`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::MissingAttributeName => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/AttributeName' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/AttributeName",
                                            },
            ConstraintViolation::MissingAttributeType => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/AttributeType' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/AttributeType",
                                            },
            ConstraintViolation::AttributeType(inner) => inner.as_validation_exception_field(path + "/AttributeType"),
        }
    }
                }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::model::AttributeDefinition> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::model::AttributeDefinition {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`AttributeDefinition`](crate::model::AttributeDefinition).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_name: ::std::option::Option<::std::string::String>,
        pub(crate) attribute_type: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ScalarAttributeType>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn attribute_name(mut self, input: ::std::string::String) -> Self {
            self.attribute_name =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_attribute_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
            self.attribute_name = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn attribute_type(mut self, input: crate::model::ScalarAttributeType) -> Self {
            self.attribute_type =
                Some(
                    crate::constrained::MaybeConstrained::Constrained(input)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_attribute_type(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::ScalarAttributeType>>) -> Self {
            self.attribute_type = Some(input.into());
                            self
        }
        /// Consumes the builder and constructs a [`AttributeDefinition`](crate::model::AttributeDefinition).
        /// 
        /// The builder fails to construct a [`AttributeDefinition`](crate::model::AttributeDefinition) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::AttributeDefinition , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::AttributeDefinition , ConstraintViolation> {
            Ok(
                crate::model::AttributeDefinition {
                    attribute_name: self.attribute_name
                        .ok_or(ConstraintViolation::MissingAttributeName)?
                    ,
                    attribute_type: self.attribute_type
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::AttributeType)
                                    )
                                    .transpose()?
                        .ok_or(ConstraintViolation::MissingAttributeType)?
                    ,
                }
            )
        }
    }
    
    
    
    
}
pub mod tag_list {
    
    #[allow(clippy::enum_variant_names)]
                    #[derive(Debug, PartialEq)]
                    pub enum ConstraintViolation {
                        /// Constraint violation error when an element doesn't satisfy its own constraints.
                            /// The first component of the tuple is the index in the collection where the
                            /// first constraint violation was found.
                            #[doc(hidden)]
                            Member(usize, crate::model::tag::ConstraintViolation)
                    }
                    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            let message = match self {
                                Self::Member(index, failing_member) => format!("Value at index {index} failed to satisfy constraint. {}",
                           failing_member)
                            };
                            write!(f, "{message}")
                        }
                    }
                    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                    match self {
                        Self::Member(index, member_constraint_violation) =>
                        member_constraint_violation.as_validation_exception_field(path + "/" + &index.to_string())
                    }
                }
                        }
    
    
    
    
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `key` was not provided but it is required when building `Tag`.
        MissingKey,
        /// `value` was not provided but it is required when building `Tag`.
        MissingValue,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingKey => write!(f, "`key` was not provided but it is required when building `Tag`"),
                ConstraintViolation::MissingValue => write!(f, "`value` was not provided but it is required when building `Tag`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::MissingKey => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/Key' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/Key",
                                            },
            ConstraintViolation::MissingValue => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/Value' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/Value",
                                            },
        }
    }
                }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::model::Tag> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::model::Tag {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`Tag`](crate::model::Tag).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: ::std::option::Option<::std::string::String>,
        pub(crate) value: ::std::option::Option<::std::string::String>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn key(mut self, input: ::std::string::String) -> Self {
            self.key =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_key(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
            self.key = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn value(mut self, input: ::std::string::String) -> Self {
            self.value =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_value(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
            self.value = Some(input.into());
                            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        /// 
        /// The builder fails to construct a [`Tag`](crate::model::Tag) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::Tag , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::Tag , ConstraintViolation> {
            Ok(
                crate::model::Tag {
                    key: self.key
                        .ok_or(ConstraintViolation::MissingKey)?
                    ,
                    value: self.value
                        .ok_or(ConstraintViolation::MissingValue)?
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`SseSpecification`](crate::model::SseSpecification).
pub mod sse_specification {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// Constraint violation occurred building member `sse_type` when building `SseSpecification`.
        #[doc(hidden)]
        SseType(crate::model::sse_type::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::SseType(_) => write!(f, "constraint violation occurred building member `sse_type` when building `SseSpecification`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::SseType(inner) => inner.as_validation_exception_field(path + "/SSEType"),
        }
    }
                }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::model::SseSpecification> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::model::SseSpecification {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`SseSpecification`](crate::model::SseSpecification).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enabled: ::std::option::Option<bool>,
        pub(crate) sse_type: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::SSEType>>,
        pub(crate) kms_master_key_id: ::std::option::Option<::std::string::String>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn enabled(mut self, input: ::std::option::Option<bool>) -> Self {
            self.enabled =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_enabled(mut self, input: Option<impl ::std::convert::Into<bool>>) -> Self {
            self.enabled = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn sse_type(mut self, input: ::std::option::Option<crate::model::SSEType>) -> Self {
            self.sse_type =
                input.map(#[allow(clippy::redundant_closure)] |v|
                    crate::constrained::MaybeConstrained::Constrained(v)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_sse_type(mut self, input: Option<impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::SSEType>>>) -> Self {
            self.sse_type = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn kms_master_key_id(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.kms_master_key_id =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_kms_master_key_id(mut self, input: Option<impl ::std::convert::Into<::std::string::String>>) -> Self {
            self.kms_master_key_id = input.map(|v| v.into());
                            self
        }
        /// Consumes the builder and constructs a [`SseSpecification`](crate::model::SseSpecification).
        /// 
        /// The builder fails to construct a [`SseSpecification`](crate::model::SseSpecification) if a [`ConstraintViolation`] occurs.
        /// 
        pub fn build(self) -> Result<crate::model::SseSpecification , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::SseSpecification , ConstraintViolation> {
            Ok(
                crate::model::SseSpecification {
                    enabled: self.enabled
                    ,
                    sse_type: self.sse_type
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::SseType)
                                    )
                                    .transpose()?
                    ,
                    kms_master_key_id: self.kms_master_key_id
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`ProvisionedThroughput`](crate::model::ProvisionedThroughput).
pub mod provisioned_throughput {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `read_capacity_units` was not provided but it is required when building `ProvisionedThroughput`.
        MissingReadCapacityUnits,
        /// `write_capacity_units` was not provided but it is required when building `ProvisionedThroughput`.
        MissingWriteCapacityUnits,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingReadCapacityUnits => write!(f, "`read_capacity_units` was not provided but it is required when building `ProvisionedThroughput`"),
                ConstraintViolation::MissingWriteCapacityUnits => write!(f, "`write_capacity_units` was not provided but it is required when building `ProvisionedThroughput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::MissingReadCapacityUnits => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/ReadCapacityUnits' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/ReadCapacityUnits",
                                            },
            ConstraintViolation::MissingWriteCapacityUnits => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/WriteCapacityUnits' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/WriteCapacityUnits",
                                            },
        }
    }
                }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::model::ProvisionedThroughput> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::model::ProvisionedThroughput {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`ProvisionedThroughput`](crate::model::ProvisionedThroughput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_capacity_units: ::std::option::Option<i64>,
        pub(crate) write_capacity_units: ::std::option::Option<i64>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn read_capacity_units(mut self, input: i64) -> Self {
            self.read_capacity_units =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_read_capacity_units(mut self, input: impl ::std::convert::Into<i64>) -> Self {
            self.read_capacity_units = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn write_capacity_units(mut self, input: i64) -> Self {
            self.write_capacity_units =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_write_capacity_units(mut self, input: impl ::std::convert::Into<i64>) -> Self {
            self.write_capacity_units = Some(input.into());
                            self
        }
        /// Consumes the builder and constructs a [`ProvisionedThroughput`](crate::model::ProvisionedThroughput).
        /// 
        /// The builder fails to construct a [`ProvisionedThroughput`](crate::model::ProvisionedThroughput) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::ProvisionedThroughput , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::ProvisionedThroughput , ConstraintViolation> {
            Ok(
                crate::model::ProvisionedThroughput {
                    read_capacity_units: self.read_capacity_units
                        .ok_or(ConstraintViolation::MissingReadCapacityUnits)?
                    ,
                    write_capacity_units: self.write_capacity_units
                        .ok_or(ConstraintViolation::MissingWriteCapacityUnits)?
                    ,
                }
            )
        }
    }
    
    
    
    
}
pub mod global_secondary_index_list {
    
    #[allow(clippy::enum_variant_names)]
                    #[derive(Debug, PartialEq)]
                    pub enum ConstraintViolation {
                        /// Constraint violation error when an element doesn't satisfy its own constraints.
                            /// The first component of the tuple is the index in the collection where the
                            /// first constraint violation was found.
                            #[doc(hidden)]
                            Member(usize, crate::model::global_secondary_index::ConstraintViolation)
                    }
                    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            let message = match self {
                                Self::Member(index, failing_member) => format!("Value at index {index} failed to satisfy constraint. {}",
                           failing_member)
                            };
                            write!(f, "{message}")
                        }
                    }
                    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                    match self {
                        Self::Member(index, member_constraint_violation) =>
                        member_constraint_violation.as_validation_exception_field(path + "/" + &index.to_string())
                    }
                }
                        }
    
    
    
    
}
/// See [`GlobalSecondaryIndex`](crate::model::GlobalSecondaryIndex).
pub mod global_secondary_index {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `index_name` was not provided but it is required when building `GlobalSecondaryIndex`.
        MissingIndexName,
        /// `key_schema` was not provided but it is required when building `GlobalSecondaryIndex`.
        MissingKeySchema,
        /// Constraint violation occurred building member `key_schema` when building `GlobalSecondaryIndex`.
        #[doc(hidden)]
        KeySchema(crate::model::key_schema::ConstraintViolation),
        /// `projection` was not provided but it is required when building `GlobalSecondaryIndex`.
        MissingProjection,
        /// Constraint violation occurred building member `projection` when building `GlobalSecondaryIndex`.
        #[doc(hidden)]
        Projection(crate::model::projection::ConstraintViolation),
        /// Constraint violation occurred building member `provisioned_throughput` when building `GlobalSecondaryIndex`.
        #[doc(hidden)]
        ProvisionedThroughput(crate::model::provisioned_throughput::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingIndexName => write!(f, "`index_name` was not provided but it is required when building `GlobalSecondaryIndex`"),
                ConstraintViolation::MissingKeySchema => write!(f, "`key_schema` was not provided but it is required when building `GlobalSecondaryIndex`"),
                ConstraintViolation::KeySchema(_) => write!(f, "constraint violation occurred building member `key_schema` when building `GlobalSecondaryIndex`"),
                ConstraintViolation::MissingProjection => write!(f, "`projection` was not provided but it is required when building `GlobalSecondaryIndex`"),
                ConstraintViolation::Projection(_) => write!(f, "constraint violation occurred building member `projection` when building `GlobalSecondaryIndex`"),
                ConstraintViolation::ProvisionedThroughput(_) => write!(f, "constraint violation occurred building member `provisioned_throughput` when building `GlobalSecondaryIndex`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::MissingIndexName => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/IndexName' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/IndexName",
                                            },
            ConstraintViolation::MissingKeySchema => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/KeySchema' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/KeySchema",
                                            },
            ConstraintViolation::KeySchema(inner) => inner.as_validation_exception_field(path + "/KeySchema"),
            ConstraintViolation::MissingProjection => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/Projection' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/Projection",
                                            },
            ConstraintViolation::Projection(inner) => inner.as_validation_exception_field(path + "/Projection"),
            ConstraintViolation::ProvisionedThroughput(inner) => inner.as_validation_exception_field(path + "/ProvisionedThroughput"),
        }
    }
                }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::model::GlobalSecondaryIndex> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::model::GlobalSecondaryIndex {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`GlobalSecondaryIndex`](crate::model::GlobalSecondaryIndex).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: ::std::option::Option<::std::string::String>,
        pub(crate) key_schema: ::std::option::Option<crate::constrained::MaybeConstrained<crate::constrained::key_schema_constrained::KeySchemaConstrained>>,
        pub(crate) projection: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::Projection>>,
        pub(crate) provisioned_throughput: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ProvisionedThroughput>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn index_name(mut self, input: ::std::string::String) -> Self {
            self.index_name =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_index_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
            self.index_name = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn key_schema(mut self, input: ::std::vec::Vec::<crate::model::KeySchemaElement>) -> Self {
            self.key_schema =
                Some(
                    crate::constrained::MaybeConstrained::Constrained((input).into())
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_key_schema(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::constrained::key_schema_constrained::KeySchemaConstrained>>) -> Self {
            self.key_schema = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn projection(mut self, input: crate::model::Projection) -> Self {
            self.projection =
                Some(
                    crate::constrained::MaybeConstrained::Constrained(input)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_projection(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::Projection>>) -> Self {
            self.projection = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn provisioned_throughput(mut self, input: ::std::option::Option<crate::model::ProvisionedThroughput>) -> Self {
            self.provisioned_throughput =
                input.map(#[allow(clippy::redundant_closure)] |v|
                    crate::constrained::MaybeConstrained::Constrained(v)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_provisioned_throughput(mut self, input: Option<impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::ProvisionedThroughput>>>) -> Self {
            self.provisioned_throughput = input.map(|v| v.into());
                            self
        }
        /// Consumes the builder and constructs a [`GlobalSecondaryIndex`](crate::model::GlobalSecondaryIndex).
        /// 
        /// The builder fails to construct a [`GlobalSecondaryIndex`](crate::model::GlobalSecondaryIndex) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::GlobalSecondaryIndex , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::GlobalSecondaryIndex , ConstraintViolation> {
            Ok(
                crate::model::GlobalSecondaryIndex {
                    index_name: self.index_name
                        .ok_or(ConstraintViolation::MissingIndexName)?
                    ,
                    key_schema: self.key_schema
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map(|v| v.into()).map_err(ConstraintViolation::KeySchema)
                                    )
                                    .transpose()?
                        .ok_or(ConstraintViolation::MissingKeySchema)?
                    ,
                    projection: self.projection
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::Projection)
                                    )
                                    .transpose()?
                        .ok_or(ConstraintViolation::MissingProjection)?
                    ,
                    provisioned_throughput: self.provisioned_throughput
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::ProvisionedThroughput)
                                    )
                                    .transpose()?
                    ,
                }
            )
        }
    }
    
    
    
    
}
pub mod local_secondary_index_list {
    
    #[allow(clippy::enum_variant_names)]
                    #[derive(Debug, PartialEq)]
                    pub enum ConstraintViolation {
                        /// Constraint violation error when an element doesn't satisfy its own constraints.
                            /// The first component of the tuple is the index in the collection where the
                            /// first constraint violation was found.
                            #[doc(hidden)]
                            Member(usize, crate::model::local_secondary_index::ConstraintViolation)
                    }
                    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            let message = match self {
                                Self::Member(index, failing_member) => format!("Value at index {index} failed to satisfy constraint. {}",
                           failing_member)
                            };
                            write!(f, "{message}")
                        }
                    }
                    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
                    match self {
                        Self::Member(index, member_constraint_violation) =>
                        member_constraint_violation.as_validation_exception_field(path + "/" + &index.to_string())
                    }
                }
                        }
    
    
    
    
}
/// See [`LocalSecondaryIndex`](crate::model::LocalSecondaryIndex).
pub mod local_secondary_index {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `index_name` was not provided but it is required when building `LocalSecondaryIndex`.
        MissingIndexName,
        /// `key_schema` was not provided but it is required when building `LocalSecondaryIndex`.
        MissingKeySchema,
        /// Constraint violation occurred building member `key_schema` when building `LocalSecondaryIndex`.
        #[doc(hidden)]
        KeySchema(crate::model::key_schema::ConstraintViolation),
        /// `projection` was not provided but it is required when building `LocalSecondaryIndex`.
        MissingProjection,
        /// Constraint violation occurred building member `projection` when building `LocalSecondaryIndex`.
        #[doc(hidden)]
        Projection(crate::model::projection::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingIndexName => write!(f, "`index_name` was not provided but it is required when building `LocalSecondaryIndex`"),
                ConstraintViolation::MissingKeySchema => write!(f, "`key_schema` was not provided but it is required when building `LocalSecondaryIndex`"),
                ConstraintViolation::KeySchema(_) => write!(f, "constraint violation occurred building member `key_schema` when building `LocalSecondaryIndex`"),
                ConstraintViolation::MissingProjection => write!(f, "`projection` was not provided but it is required when building `LocalSecondaryIndex`"),
                ConstraintViolation::Projection(_) => write!(f, "constraint violation occurred building member `projection` when building `LocalSecondaryIndex`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::MissingIndexName => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/IndexName' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/IndexName",
                                            },
            ConstraintViolation::MissingKeySchema => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/KeySchema' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/KeySchema",
                                            },
            ConstraintViolation::KeySchema(inner) => inner.as_validation_exception_field(path + "/KeySchema"),
            ConstraintViolation::MissingProjection => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/Projection' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/Projection",
                                            },
            ConstraintViolation::Projection(inner) => inner.as_validation_exception_field(path + "/Projection"),
        }
    }
                }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::model::LocalSecondaryIndex> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::model::LocalSecondaryIndex {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`LocalSecondaryIndex`](crate::model::LocalSecondaryIndex).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) index_name: ::std::option::Option<::std::string::String>,
        pub(crate) key_schema: ::std::option::Option<crate::constrained::MaybeConstrained<crate::constrained::key_schema_constrained::KeySchemaConstrained>>,
        pub(crate) projection: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::Projection>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn index_name(mut self, input: ::std::string::String) -> Self {
            self.index_name =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_index_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
            self.index_name = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn key_schema(mut self, input: ::std::vec::Vec::<crate::model::KeySchemaElement>) -> Self {
            self.key_schema =
                Some(
                    crate::constrained::MaybeConstrained::Constrained((input).into())
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_key_schema(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::constrained::key_schema_constrained::KeySchemaConstrained>>) -> Self {
            self.key_schema = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn projection(mut self, input: crate::model::Projection) -> Self {
            self.projection =
                Some(
                    crate::constrained::MaybeConstrained::Constrained(input)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_projection(mut self, input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::Projection>>) -> Self {
            self.projection = Some(input.into());
                            self
        }
        /// Consumes the builder and constructs a [`LocalSecondaryIndex`](crate::model::LocalSecondaryIndex).
        /// 
        /// The builder fails to construct a [`LocalSecondaryIndex`](crate::model::LocalSecondaryIndex) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::model::LocalSecondaryIndex , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::LocalSecondaryIndex , ConstraintViolation> {
            Ok(
                crate::model::LocalSecondaryIndex {
                    index_name: self.index_name
                        .ok_or(ConstraintViolation::MissingIndexName)?
                    ,
                    key_schema: self.key_schema
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map(|v| v.into()).map_err(ConstraintViolation::KeySchema)
                                    )
                                    .transpose()?
                        .ok_or(ConstraintViolation::MissingKeySchema)?
                    ,
                    projection: self.projection
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::Projection)
                                    )
                                    .transpose()?
                        .ok_or(ConstraintViolation::MissingProjection)?
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`ItemCollectionMetrics`](crate::model::ItemCollectionMetrics).
pub mod item_collection_metrics {
    
    impl ::std::convert::From<Builder > for crate::model::ItemCollectionMetrics  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`ItemCollectionMetrics`](crate::model::ItemCollectionMetrics).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) item_collection_key: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>,
        pub(crate) size_estimate_range_gb: ::std::option::Option<::std::vec::Vec::<f64>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn item_collection_key(mut self, input: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>) -> Self {
            self.item_collection_key =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn size_estimate_range_gb(mut self, input: ::std::option::Option<::std::vec::Vec::<f64>>) -> Self {
            self.size_estimate_range_gb =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`ItemCollectionMetrics`](crate::model::ItemCollectionMetrics).
        pub fn build(self) -> crate::model::ItemCollectionMetrics {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::ItemCollectionMetrics {
            crate::model::ItemCollectionMetrics {
                item_collection_key: self.item_collection_key
                ,
                size_estimate_range_gb: self.size_estimate_range_gb
                ,
            }
        }
    }
    
    
    
    
}
/// See [`ConsumedCapacity`](crate::model::ConsumedCapacity).
pub mod consumed_capacity {
    
    impl ::std::convert::From<Builder > for crate::model::ConsumedCapacity  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`ConsumedCapacity`](crate::model::ConsumedCapacity).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: ::std::option::Option<::std::string::String>,
        pub(crate) capacity_units: ::std::option::Option<f64>,
        pub(crate) read_capacity_units: ::std::option::Option<f64>,
        pub(crate) write_capacity_units: ::std::option::Option<f64>,
        pub(crate) table: ::std::option::Option<crate::model::Capacity>,
        pub(crate) local_secondary_indexes: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::Capacity>>,
        pub(crate) global_secondary_indexes: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::Capacity>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.table_name =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn capacity_units(mut self, input: ::std::option::Option<f64>) -> Self {
            self.capacity_units =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn read_capacity_units(mut self, input: ::std::option::Option<f64>) -> Self {
            self.read_capacity_units =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn write_capacity_units(mut self, input: ::std::option::Option<f64>) -> Self {
            self.write_capacity_units =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn table(mut self, input: ::std::option::Option<crate::model::Capacity>) -> Self {
            self.table =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn local_secondary_indexes(mut self, input: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::Capacity>>) -> Self {
            self.local_secondary_indexes =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn global_secondary_indexes(mut self, input: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::Capacity>>) -> Self {
            self.global_secondary_indexes =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`ConsumedCapacity`](crate::model::ConsumedCapacity).
        pub fn build(self) -> crate::model::ConsumedCapacity {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::ConsumedCapacity {
            crate::model::ConsumedCapacity {
                table_name: self.table_name
                ,
                capacity_units: self.capacity_units
                ,
                read_capacity_units: self.read_capacity_units
                ,
                write_capacity_units: self.write_capacity_units
                ,
                table: self.table
                ,
                local_secondary_indexes: self.local_secondary_indexes
                ,
                global_secondary_indexes: self.global_secondary_indexes
                ,
            }
        }
    }
    
    
    
    
}
/// See [`Capacity`](crate::model::Capacity).
pub mod capacity {
    
    impl ::std::convert::From<Builder > for crate::model::Capacity  {
                    fn from(builder: Builder) -> Self {
                        builder.build()
                    }
                }
    /// A builder for [`Capacity`](crate::model::Capacity).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) read_capacity_units: ::std::option::Option<f64>,
        pub(crate) write_capacity_units: ::std::option::Option<f64>,
        pub(crate) capacity_units: ::std::option::Option<f64>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn read_capacity_units(mut self, input: ::std::option::Option<f64>) -> Self {
            self.read_capacity_units =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn write_capacity_units(mut self, input: ::std::option::Option<f64>) -> Self {
            self.write_capacity_units =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn capacity_units(mut self, input: ::std::option::Option<f64>) -> Self {
            self.capacity_units =
                input
            ; self
        }
        /// Consumes the builder and constructs a [`Capacity`](crate::model::Capacity).
        pub fn build(self) -> crate::model::Capacity {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> crate::model::Capacity {
            crate::model::Capacity {
                read_capacity_units: self.read_capacity_units
                ,
                write_capacity_units: self.write_capacity_units
                ,
                capacity_units: self.capacity_units
                ,
            }
        }
    }
    
    
    
    
}
pub mod expected_attribute_map {
    
    #[allow(clippy::enum_variant_names)]
                    #[derive(Debug, PartialEq)]
                    pub enum ConstraintViolation {
                        
                        
                        #[doc(hidden)] Value(::std::string::String, crate::model::expected_attribute_value::ConstraintViolation),
                    }
                    
                    impl ::std::fmt::Display for ConstraintViolation {
                        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                            match self {
                                
                                
                                Self::Value(_, value_constraint_violation) => write!(f, "{}", value_constraint_violation),
                            }
                        }
                    }
                    
                    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
                            pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            Self::Value(key, value_constraint_violation) => value_constraint_violation.as_validation_exception_field(path + "/" + key.as_str()),
        }
    }
                        }
    
    
    
    
}
/// See [`ExpectedAttributeValue`](crate::model::ExpectedAttributeValue).
pub mod expected_attribute_value {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// Constraint violation occurred building member `comparison_operator` when building `ExpectedAttributeValue`.
        #[doc(hidden)]
        ComparisonOperator(crate::model::comparison_operator::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::ComparisonOperator(_) => write!(f, "constraint violation occurred building member `comparison_operator` when building `ExpectedAttributeValue`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::ComparisonOperator(inner) => inner.as_validation_exception_field(path + "/ComparisonOperator"),
        }
    }
                }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::model::ExpectedAttributeValue> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::model::ExpectedAttributeValue {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`ExpectedAttributeValue`](crate::model::ExpectedAttributeValue).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) value: ::std::option::Option<crate::model::AttributeValue>,
        pub(crate) exists: ::std::option::Option<bool>,
        pub(crate) comparison_operator: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ComparisonOperator>>,
        pub(crate) attribute_value_list: ::std::option::Option<::std::vec::Vec::<crate::model::AttributeValue>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn value(mut self, input: ::std::option::Option<crate::model::AttributeValue>) -> Self {
            self.value =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_value(mut self, input: Option<impl ::std::convert::Into<crate::model::AttributeValue>>) -> Self {
            self.value = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn exists(mut self, input: ::std::option::Option<bool>) -> Self {
            self.exists =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_exists(mut self, input: Option<impl ::std::convert::Into<bool>>) -> Self {
            self.exists = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn comparison_operator(mut self, input: ::std::option::Option<crate::model::ComparisonOperator>) -> Self {
            self.comparison_operator =
                input.map(#[allow(clippy::redundant_closure)] |v|
                    crate::constrained::MaybeConstrained::Constrained(v)
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_comparison_operator(mut self, input: Option<impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::model::ComparisonOperator>>>) -> Self {
            self.comparison_operator = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn attribute_value_list(mut self, input: ::std::option::Option<::std::vec::Vec::<crate::model::AttributeValue>>) -> Self {
            self.attribute_value_list =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_attribute_value_list(mut self, input: Option<impl ::std::convert::Into<::std::vec::Vec::<crate::model::AttributeValue>>>) -> Self {
            self.attribute_value_list = input.map(|v| v.into());
                            self
        }
        /// Consumes the builder and constructs a [`ExpectedAttributeValue`](crate::model::ExpectedAttributeValue).
        /// 
        /// The builder fails to construct a [`ExpectedAttributeValue`](crate::model::ExpectedAttributeValue) if a [`ConstraintViolation`] occurs.
        /// 
        pub fn build(self) -> Result<crate::model::ExpectedAttributeValue , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::model::ExpectedAttributeValue , ConstraintViolation> {
            Ok(
                crate::model::ExpectedAttributeValue {
                    value: self.value
                    ,
                    exists: self.exists
                    ,
                    comparison_operator: self.comparison_operator
                        .map(|v| match v {
                                            crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                                            crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                                        })
                        .map(|res|
                                        res.map_err(ConstraintViolation::ComparisonOperator)
                                    )
                                    .transpose()?
                    ,
                    attribute_value_list: self.attribute_value_list
                    ,
                }
            )
        }
    }
    
    
    
    
}

