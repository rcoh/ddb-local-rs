// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct PutItemInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub table_name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub item: ::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>,
    #[allow(missing_docs)] // documentation missing in model
    pub condition_expression: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub expression_attribute_names: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>,
    #[allow(missing_docs)] // documentation missing in model
    pub expression_attribute_values: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>,
}
impl  PutItemInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_name(&self) -> &str {
        use std::ops::Deref; self.table_name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn item(&self) -> &::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue> {
        &self.item
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn condition_expression(&self) -> ::std::option::Option<&str> {
        self.condition_expression.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expression_attribute_names(&self) -> ::std::option::Option<&::std::collections::HashMap::<::std::string::String, ::std::string::String>> {
        self.expression_attribute_names.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expression_attribute_values(&self) -> ::std::option::Option<&::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>> {
        self.expression_attribute_values.as_ref()
    }
}
impl  PutItemInput  {
    /// Creates a new builder-style object to manufacture [`PutItemInput`](crate::input::PutItemInput).
    pub fn builder() -> crate::input::put_item_input::Builder  {
        crate::input::put_item_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::PutItemInput {
                type Unconstrained = crate::input::put_item_input::Builder;
            }

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GetItemInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub table_name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub key: ::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>,
    #[allow(missing_docs)] // documentation missing in model
    pub consistent_read: ::std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub projection_expression: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub expression_attribute_names: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>,
}
impl  GetItemInput  {
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_name(&self) -> &str {
        use std::ops::Deref; self.table_name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn key(&self) -> &::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue> {
        &self.key
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn consistent_read(&self) -> ::std::option::Option<bool> {
        self.consistent_read
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn projection_expression(&self) -> ::std::option::Option<&str> {
        self.projection_expression.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expression_attribute_names(&self) -> ::std::option::Option<&::std::collections::HashMap::<::std::string::String, ::std::string::String>> {
        self.expression_attribute_names.as_ref()
    }
}
impl  GetItemInput  {
    /// Creates a new builder-style object to manufacture [`GetItemInput`](crate::input::GetItemInput).
    pub fn builder() -> crate::input::get_item_input::Builder  {
        crate::input::get_item_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::GetItemInput {
                type Unconstrained = crate::input::get_item_input::Builder;
            }
/// See [`PutItemInput`](crate::input::PutItemInput).
pub mod put_item_input {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `table_name` was not provided but it is required when building `PutItemInput`.
        MissingTableName,
        /// `item` was not provided but it is required when building `PutItemInput`.
        MissingItem,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingTableName => write!(f, "`table_name` was not provided but it is required when building `PutItemInput`"),
                ConstraintViolation::MissingItem => write!(f, "`item` was not provided but it is required when building `PutItemInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::MissingTableName => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/TableName' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/TableName",
                                            },
            ConstraintViolation::MissingItem => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/Item' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/Item",
                                            },
        }
    }
                }
    impl ::std::convert::From<ConstraintViolation> for ::aws_smithy_http_server::protocol::aws_json::rejection::RequestRejection {
                        fn from(constraint_violation: ConstraintViolation) -> Self {
                            let first_validation_exception_field = constraint_violation.as_validation_exception_field("".to_owned());
                            let validation_exception = crate::error::ValidationException {
                                message: format!("1 validation error detected. {}", &first_validation_exception_field.message),
                                field_list: Some(vec![first_validation_exception_field]),
                            };
                            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
                        }
                    }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::input::PutItemInput> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::input::PutItemInput {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`PutItemInput`](crate::input::PutItemInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: ::std::option::Option<::std::string::String>,
        pub(crate) item: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>,
        pub(crate) condition_expression: ::std::option::Option<::std::string::String>,
        pub(crate) expression_attribute_names: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>,
        pub(crate) expression_attribute_values: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_name(mut self, input: ::std::string::String) -> Self {
            self.table_name =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_table_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
            self.table_name = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn item(mut self, input: ::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>) -> Self {
            self.item =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_item(mut self, input: impl ::std::convert::Into<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>) -> Self {
            self.item = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn condition_expression(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.condition_expression =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_condition_expression(mut self, input: Option<impl ::std::convert::Into<::std::string::String>>) -> Self {
            self.condition_expression = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expression_attribute_names(mut self, input: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>) -> Self {
            self.expression_attribute_names =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_expression_attribute_names(mut self, input: Option<impl ::std::convert::Into<::std::collections::HashMap::<::std::string::String, ::std::string::String>>>) -> Self {
            self.expression_attribute_names = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expression_attribute_values(mut self, input: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>) -> Self {
            self.expression_attribute_values =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_expression_attribute_values(mut self, input: Option<impl ::std::convert::Into<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>>) -> Self {
            self.expression_attribute_values = input.map(|v| v.into());
                            self
        }
        /// Consumes the builder and constructs a [`PutItemInput`](crate::input::PutItemInput).
        /// 
        /// The builder fails to construct a [`PutItemInput`](crate::input::PutItemInput) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::PutItemInput , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::input::PutItemInput , ConstraintViolation> {
            Ok(
                crate::input::PutItemInput {
                    table_name: self.table_name
                        .ok_or(ConstraintViolation::MissingTableName)?
                    ,
                    item: self.item
                        .ok_or(ConstraintViolation::MissingItem)?
                    ,
                    condition_expression: self.condition_expression
                    ,
                    expression_attribute_names: self.expression_attribute_names
                    ,
                    expression_attribute_values: self.expression_attribute_values
                    ,
                }
            )
        }
    }
    
    
    
    
}
/// See [`GetItemInput`](crate::input::GetItemInput).
pub mod get_item_input {
    
    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
                pub enum ConstraintViolation {
        /// `table_name` was not provided but it is required when building `GetItemInput`.
        MissingTableName,
        /// `key` was not provided but it is required when building `GetItemInput`.
        MissingKey,
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingTableName => write!(f, "`table_name` was not provided but it is required when building `GetItemInput`"),
                ConstraintViolation::MissingKey => write!(f, "`key` was not provided but it is required when building `GetItemInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation { }
    impl ConstraintViolation {
                    pub(crate) fn as_validation_exception_field(self, path: ::std::string::String) -> crate::model::ValidationExceptionField {
        match self {
            ConstraintViolation::MissingTableName => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/TableName' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/TableName",
                                            },
            ConstraintViolation::MissingKey => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/Key' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/Key",
                                            },
        }
    }
                }
    impl ::std::convert::From<ConstraintViolation> for ::aws_smithy_http_server::protocol::aws_json::rejection::RequestRejection {
                        fn from(constraint_violation: ConstraintViolation) -> Self {
                            let first_validation_exception_field = constraint_violation.as_validation_exception_field("".to_owned());
                            let validation_exception = crate::error::ValidationException {
                                message: format!("1 validation error detected. {}", &first_validation_exception_field.message),
                                field_list: Some(vec![first_validation_exception_field]),
                            };
                            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
                        }
                    }
    impl ::std::convert::From<Builder> for crate::constrained::MaybeConstrained<crate::input::GetItemInput> {
                    fn from(builder: Builder) -> Self {
                        Self::Unconstrained(builder)
                    }
                }
    impl  ::std::convert::TryFrom<Builder > for crate::input::GetItemInput {
                    type Error = ConstraintViolation;
    
                    fn try_from(builder: Builder ) -> ::std::result::Result<Self, Self::Error> {
                        builder.build()
                    }
                }
    /// A builder for [`GetItemInput`](crate::input::GetItemInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: ::std::option::Option<::std::string::String>,
        pub(crate) key: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>,
        pub(crate) consistent_read: ::std::option::Option<bool>,
        pub(crate) projection_expression: ::std::option::Option<::std::string::String>,
        pub(crate) expression_attribute_names: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>,
    }
    impl  Builder  {
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_name(mut self, input: ::std::string::String) -> Self {
            self.table_name =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_table_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
            self.table_name = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn key(mut self, input: ::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>) -> Self {
            self.key =
                Some(
                    input
                )
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_key(mut self, input: impl ::std::convert::Into<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>) -> Self {
            self.key = Some(input.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn consistent_read(mut self, input: ::std::option::Option<bool>) -> Self {
            self.consistent_read =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_consistent_read(mut self, input: Option<impl ::std::convert::Into<bool>>) -> Self {
            self.consistent_read = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn projection_expression(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
            self.projection_expression =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_projection_expression(mut self, input: Option<impl ::std::convert::Into<::std::string::String>>) -> Self {
            self.projection_expression = input.map(|v| v.into());
                            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expression_attribute_names(mut self, input: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>) -> Self {
            self.expression_attribute_names =
                input
            ; self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_expression_attribute_names(mut self, input: Option<impl ::std::convert::Into<::std::collections::HashMap::<::std::string::String, ::std::string::String>>>) -> Self {
            self.expression_attribute_names = input.map(|v| v.into());
                            self
        }
        /// Consumes the builder and constructs a [`GetItemInput`](crate::input::GetItemInput).
        /// 
        /// The builder fails to construct a [`GetItemInput`](crate::input::GetItemInput) if a [`ConstraintViolation`] occurs.
        /// 
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::GetItemInput , ConstraintViolation> {
                        self.build_enforcing_all_constraints()
                    }
        fn build_enforcing_all_constraints(self) -> Result<crate::input::GetItemInput , ConstraintViolation> {
            Ok(
                crate::input::GetItemInput {
                    table_name: self.table_name
                        .ok_or(ConstraintViolation::MissingTableName)?
                    ,
                    key: self.key
                        .ok_or(ConstraintViolation::MissingKey)?
                    ,
                    consistent_read: self.consistent_read
                    ,
                    projection_expression: self.projection_expression
                    ,
                    expression_attribute_names: self.expression_attribute_names
                    ,
                }
            )
        }
    }
    
    
    
    
}

