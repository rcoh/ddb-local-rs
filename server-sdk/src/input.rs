// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct UpdateItemInput {
    #[allow(missing_docs)] // documentation missing in model
    pub table_name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub key: ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
    #[allow(missing_docs)] // documentation missing in model
    pub attribute_updates: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, crate::model::AttributeValueUpdate>,
    >,
    #[allow(missing_docs)] // documentation missing in model
    pub expected: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, crate::model::ExpectedAttributeValue>,
    >,
    #[allow(missing_docs)] // documentation missing in model
    pub conditional_operator: ::std::option::Option<crate::model::ConditionalOperator>,
    #[allow(missing_docs)] // documentation missing in model
    pub return_values: ::std::option::Option<crate::model::ReturnValue>,
    #[allow(missing_docs)] // documentation missing in model
    pub return_consumed_capacity: ::std::option::Option<crate::model::ReturnConsumedCapacity>,
    #[allow(missing_docs)] // documentation missing in model
    pub return_item_collection_metrics:
        ::std::option::Option<crate::model::ReturnItemCollectionMetrics>,
    #[allow(missing_docs)] // documentation missing in model
    pub update_expression: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub condition_expression: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub expression_attribute_names: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    >,
    #[allow(missing_docs)] // documentation missing in model
    pub expression_attribute_values: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
    >,
}
impl UpdateItemInput {
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_name(&self) -> &str {
        use std::ops::Deref;
        self.table_name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn key(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, crate::model::AttributeValue> {
        &self.key
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn attribute_updates(
        &self,
    ) -> ::std::option::Option<
        &::std::collections::HashMap<::std::string::String, crate::model::AttributeValueUpdate>,
    > {
        self.attribute_updates.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expected(
        &self,
    ) -> ::std::option::Option<
        &::std::collections::HashMap<::std::string::String, crate::model::ExpectedAttributeValue>,
    > {
        self.expected.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn conditional_operator(
        &self,
    ) -> ::std::option::Option<&crate::model::ConditionalOperator> {
        self.conditional_operator.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn return_values(&self) -> ::std::option::Option<&crate::model::ReturnValue> {
        self.return_values.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn return_consumed_capacity(
        &self,
    ) -> ::std::option::Option<&crate::model::ReturnConsumedCapacity> {
        self.return_consumed_capacity.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn return_item_collection_metrics(
        &self,
    ) -> ::std::option::Option<&crate::model::ReturnItemCollectionMetrics> {
        self.return_item_collection_metrics.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn update_expression(&self) -> ::std::option::Option<&str> {
        self.update_expression.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn condition_expression(&self) -> ::std::option::Option<&str> {
        self.condition_expression.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expression_attribute_names(
        &self,
    ) -> ::std::option::Option<
        &::std::collections::HashMap<::std::string::String, ::std::string::String>,
    > {
        self.expression_attribute_names.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expression_attribute_values(
        &self,
    ) -> ::std::option::Option<
        &::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
    > {
        self.expression_attribute_values.as_ref()
    }
}
impl UpdateItemInput {
    /// Creates a new builder-style object to manufacture [`UpdateItemInput`](crate::input::UpdateItemInput).
    pub fn builder() -> crate::input::update_item_input::Builder {
        crate::input::update_item_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::UpdateItemInput {
    type Unconstrained = crate::input::update_item_input::Builder;
}

#[allow(missing_docs)] // documentation missing in model
#[derive(
    ::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug, ::std::hash::Hash,
)]
pub struct CreateTableInput {
    #[allow(missing_docs)] // documentation missing in model
    pub attribute_definitions: ::std::vec::Vec<crate::model::AttributeDefinition>,
    #[allow(missing_docs)] // documentation missing in model
    pub table_name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub key_schema: ::std::vec::Vec<crate::model::KeySchemaElement>,
    #[allow(missing_docs)] // documentation missing in model
    pub local_secondary_indexes:
        ::std::option::Option<::std::vec::Vec<crate::model::LocalSecondaryIndex>>,
    #[allow(missing_docs)] // documentation missing in model
    pub global_secondary_indexes:
        ::std::option::Option<::std::vec::Vec<crate::model::GlobalSecondaryIndex>>,
    #[allow(missing_docs)] // documentation missing in model
    pub billing_mode: ::std::option::Option<crate::model::BillingMode>,
    #[allow(missing_docs)] // documentation missing in model
    pub provisioned_throughput: ::std::option::Option<crate::model::ProvisionedThroughput>,
    #[allow(missing_docs)] // documentation missing in model
    pub stream_specification: ::std::option::Option<crate::model::StreamSpecification>,
    #[allow(missing_docs)] // documentation missing in model
    pub sse_specification: ::std::option::Option<crate::model::SseSpecification>,
    #[allow(missing_docs)] // documentation missing in model
    pub tags: ::std::option::Option<::std::vec::Vec<crate::model::Tag>>,
}
impl CreateTableInput {
    #[allow(missing_docs)] // documentation missing in model
    pub fn attribute_definitions(&self) -> &[crate::model::AttributeDefinition] {
        use std::ops::Deref;
        self.attribute_definitions.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_name(&self) -> &str {
        use std::ops::Deref;
        self.table_name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn key_schema(&self) -> &[crate::model::KeySchemaElement] {
        use std::ops::Deref;
        self.key_schema.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn local_secondary_indexes(
        &self,
    ) -> ::std::option::Option<&[crate::model::LocalSecondaryIndex]> {
        self.local_secondary_indexes.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn global_secondary_indexes(
        &self,
    ) -> ::std::option::Option<&[crate::model::GlobalSecondaryIndex]> {
        self.global_secondary_indexes.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn billing_mode(&self) -> ::std::option::Option<&crate::model::BillingMode> {
        self.billing_mode.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn provisioned_throughput(
        &self,
    ) -> ::std::option::Option<&crate::model::ProvisionedThroughput> {
        self.provisioned_throughput.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn stream_specification(
        &self,
    ) -> ::std::option::Option<&crate::model::StreamSpecification> {
        self.stream_specification.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn sse_specification(&self) -> ::std::option::Option<&crate::model::SseSpecification> {
        self.sse_specification.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn tags(&self) -> ::std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
impl CreateTableInput {
    /// Creates a new builder-style object to manufacture [`CreateTableInput`](crate::input::CreateTableInput).
    pub fn builder() -> crate::input::create_table_input::Builder {
        crate::input::create_table_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::CreateTableInput {
    type Unconstrained = crate::input::create_table_input::Builder;
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct PutItemInput {
    #[allow(missing_docs)] // documentation missing in model
    pub table_name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub item: ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
    #[allow(missing_docs)] // documentation missing in model
    pub expected: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, crate::model::ExpectedAttributeValue>,
    >,
    #[allow(missing_docs)] // documentation missing in model
    pub return_values: ::std::option::Option<crate::model::ReturnValue>,
    #[allow(missing_docs)] // documentation missing in model
    pub return_consumed_capacity: ::std::option::Option<crate::model::ReturnConsumedCapacity>,
    #[allow(missing_docs)] // documentation missing in model
    pub return_item_collection_metrics:
        ::std::option::Option<crate::model::ReturnItemCollectionMetrics>,
    #[allow(missing_docs)] // documentation missing in model
    pub conditional_operator: ::std::option::Option<crate::model::ConditionalOperator>,
    #[allow(missing_docs)] // documentation missing in model
    pub condition_expression: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub expression_attribute_names: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    >,
    #[allow(missing_docs)] // documentation missing in model
    pub expression_attribute_values: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
    >,
}
impl PutItemInput {
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_name(&self) -> &str {
        use std::ops::Deref;
        self.table_name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn item(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, crate::model::AttributeValue> {
        &self.item
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expected(
        &self,
    ) -> ::std::option::Option<
        &::std::collections::HashMap<::std::string::String, crate::model::ExpectedAttributeValue>,
    > {
        self.expected.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn return_values(&self) -> ::std::option::Option<&crate::model::ReturnValue> {
        self.return_values.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn return_consumed_capacity(
        &self,
    ) -> ::std::option::Option<&crate::model::ReturnConsumedCapacity> {
        self.return_consumed_capacity.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn return_item_collection_metrics(
        &self,
    ) -> ::std::option::Option<&crate::model::ReturnItemCollectionMetrics> {
        self.return_item_collection_metrics.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn conditional_operator(
        &self,
    ) -> ::std::option::Option<&crate::model::ConditionalOperator> {
        self.conditional_operator.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn condition_expression(&self) -> ::std::option::Option<&str> {
        self.condition_expression.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expression_attribute_names(
        &self,
    ) -> ::std::option::Option<
        &::std::collections::HashMap<::std::string::String, ::std::string::String>,
    > {
        self.expression_attribute_names.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expression_attribute_values(
        &self,
    ) -> ::std::option::Option<
        &::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
    > {
        self.expression_attribute_values.as_ref()
    }
}
impl PutItemInput {
    /// Creates a new builder-style object to manufacture [`PutItemInput`](crate::input::PutItemInput).
    pub fn builder() -> crate::input::put_item_input::Builder {
        crate::input::put_item_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::PutItemInput {
    type Unconstrained = crate::input::put_item_input::Builder;
}

#[allow(missing_docs)] // documentation missing in model
#[derive(::std::clone::Clone, ::std::cmp::Eq, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct GetItemInput {
    #[allow(missing_docs)] // documentation missing in model
    pub table_name: ::std::string::String,
    #[allow(missing_docs)] // documentation missing in model
    pub key: ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
    #[allow(missing_docs)] // documentation missing in model
    pub attributes_to_get: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    #[allow(missing_docs)] // documentation missing in model
    pub consistent_read: ::std::option::Option<bool>,
    #[allow(missing_docs)] // documentation missing in model
    pub return_consumed_capacity: ::std::option::Option<crate::model::ReturnConsumedCapacity>,
    #[allow(missing_docs)] // documentation missing in model
    pub projection_expression: ::std::option::Option<::std::string::String>,
    #[allow(missing_docs)] // documentation missing in model
    pub expression_attribute_names: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    >,
}
impl GetItemInput {
    #[allow(missing_docs)] // documentation missing in model
    pub fn table_name(&self) -> &str {
        use std::ops::Deref;
        self.table_name.deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn key(
        &self,
    ) -> &::std::collections::HashMap<::std::string::String, crate::model::AttributeValue> {
        &self.key
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn attributes_to_get(&self) -> ::std::option::Option<&[::std::string::String]> {
        self.attributes_to_get.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn consistent_read(&self) -> ::std::option::Option<bool> {
        self.consistent_read
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn return_consumed_capacity(
        &self,
    ) -> ::std::option::Option<&crate::model::ReturnConsumedCapacity> {
        self.return_consumed_capacity.as_ref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn projection_expression(&self) -> ::std::option::Option<&str> {
        self.projection_expression.as_deref()
    }
    #[allow(missing_docs)] // documentation missing in model
    pub fn expression_attribute_names(
        &self,
    ) -> ::std::option::Option<
        &::std::collections::HashMap<::std::string::String, ::std::string::String>,
    > {
        self.expression_attribute_names.as_ref()
    }
}
impl GetItemInput {
    /// Creates a new builder-style object to manufacture [`GetItemInput`](crate::input::GetItemInput).
    pub fn builder() -> crate::input::get_item_input::Builder {
        crate::input::get_item_input::Builder::default()
    }
}
impl crate::constrained::Constrained for crate::input::GetItemInput {
    type Unconstrained = crate::input::get_item_input::Builder;
}
/// See [`UpdateItemInput`](crate::input::UpdateItemInput).
pub mod update_item_input {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `table_name` was not provided but it is required when building `UpdateItemInput`.
        MissingTableName,
        /// `key` was not provided but it is required when building `UpdateItemInput`.
        MissingKey,
        /// Constraint violation occurred building member `attribute_updates` when building `UpdateItemInput`.
        #[doc(hidden)]
        AttributeUpdates(crate::model::attribute_updates::ConstraintViolation),
        /// Constraint violation occurred building member `expected` when building `UpdateItemInput`.
        #[doc(hidden)]
        Expected(crate::model::expected_attribute_map::ConstraintViolation),
        /// Constraint violation occurred building member `conditional_operator` when building `UpdateItemInput`.
        #[doc(hidden)]
        ConditionalOperator(crate::model::conditional_operator::ConstraintViolation),
        /// Constraint violation occurred building member `return_values` when building `UpdateItemInput`.
        #[doc(hidden)]
        ReturnValues(crate::model::return_value::ConstraintViolation),
        /// Constraint violation occurred building member `return_consumed_capacity` when building `UpdateItemInput`.
        #[doc(hidden)]
        ReturnConsumedCapacity(crate::model::return_consumed_capacity::ConstraintViolation),
        /// Constraint violation occurred building member `return_item_collection_metrics` when building `UpdateItemInput`.
        #[doc(hidden)]
        ReturnItemCollectionMetrics(
            crate::model::return_item_collection_metrics::ConstraintViolation,
        ),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingTableName => write!(f, "`table_name` was not provided but it is required when building `UpdateItemInput`"),
                ConstraintViolation::MissingKey => write!(f, "`key` was not provided but it is required when building `UpdateItemInput`"),
                ConstraintViolation::AttributeUpdates(_) => write!(f, "constraint violation occurred building member `attribute_updates` when building `UpdateItemInput`"),
                ConstraintViolation::Expected(_) => write!(f, "constraint violation occurred building member `expected` when building `UpdateItemInput`"),
                ConstraintViolation::ConditionalOperator(_) => write!(f, "constraint violation occurred building member `conditional_operator` when building `UpdateItemInput`"),
                ConstraintViolation::ReturnValues(_) => write!(f, "constraint violation occurred building member `return_values` when building `UpdateItemInput`"),
                ConstraintViolation::ReturnConsumedCapacity(_) => write!(f, "constraint violation occurred building member `return_consumed_capacity` when building `UpdateItemInput`"),
                ConstraintViolation::ReturnItemCollectionMetrics(_) => write!(f, "constraint violation occurred building member `return_item_collection_metrics` when building `UpdateItemInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
        pub(crate) fn as_validation_exception_field(
            self,
            path: ::std::string::String,
        ) -> crate::model::ValidationExceptionField {
            match self {
            ConstraintViolation::MissingTableName => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/TableName' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/TableName",
                                            },
            ConstraintViolation::MissingKey => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/Key' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/Key",
                                            },
            ConstraintViolation::AttributeUpdates(inner) => inner.as_validation_exception_field(path + "/AttributeUpdates"),
            ConstraintViolation::Expected(inner) => inner.as_validation_exception_field(path + "/Expected"),
            ConstraintViolation::ConditionalOperator(inner) => inner.as_validation_exception_field(path + "/ConditionalOperator"),
            ConstraintViolation::ReturnValues(inner) => inner.as_validation_exception_field(path + "/ReturnValues"),
            ConstraintViolation::ReturnConsumedCapacity(inner) => inner.as_validation_exception_field(path + "/ReturnConsumedCapacity"),
            ConstraintViolation::ReturnItemCollectionMetrics(inner) => inner.as_validation_exception_field(path + "/ReturnItemCollectionMetrics"),
        }
        }
    }
    impl ::std::convert::From<ConstraintViolation>
        for ::aws_smithy_http_server::protocol::aws_json::rejection::RequestRejection
    {
        fn from(constraint_violation: ConstraintViolation) -> Self {
            let first_validation_exception_field =
                constraint_violation.as_validation_exception_field("".to_owned());
            let validation_exception = crate::error::ValidationException {
                message: format!(
                    "1 validation error detected. {}",
                    &first_validation_exception_field.message
                ),
                field_list: Some(vec![first_validation_exception_field]),
            };
            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
        }
    }
    impl ::std::convert::From<Builder>
        for crate::constrained::MaybeConstrained<crate::input::UpdateItemInput>
    {
        fn from(builder: Builder) -> Self {
            Self::Unconstrained(builder)
        }
    }
    impl ::std::convert::TryFrom<Builder> for crate::input::UpdateItemInput {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> ::std::result::Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`UpdateItemInput`](crate::input::UpdateItemInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: ::std::option::Option<::std::string::String>,
        pub(crate) key: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>,
        pub(crate) attribute_updates: ::std::option::Option<crate::constrained::MaybeConstrained<crate::constrained::attribute_updates_constrained::AttributeUpdatesConstrained>>,
        pub(crate) expected: ::std::option::Option<crate::constrained::MaybeConstrained<crate::constrained::expected_attribute_map_constrained::ExpectedAttributeMapConstrained>>,
        pub(crate) conditional_operator: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ConditionalOperator>>,
        pub(crate) return_values: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ReturnValue>>,
        pub(crate) return_consumed_capacity: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ReturnConsumedCapacity>>,
        pub(crate) return_item_collection_metrics: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ReturnItemCollectionMetrics>>,
        pub(crate) update_expression: ::std::option::Option<::std::string::String>,
        pub(crate) condition_expression: ::std::option::Option<::std::string::String>,
        pub(crate) expression_attribute_names: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>,
        pub(crate) expression_attribute_values: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_name(mut self, input: ::std::string::String) -> Self {
            self.table_name = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_table_name(
            mut self,
            input: impl ::std::convert::Into<::std::string::String>,
        ) -> Self {
            self.table_name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn key(
            mut self,
            input: ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
        ) -> Self {
            self.key = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_key(
            mut self,
            input: impl ::std::convert::Into<
                ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.key = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn attribute_updates(
            mut self,
            input: ::std::option::Option<
                ::std::collections::HashMap<
                    ::std::string::String,
                    crate::model::AttributeValueUpdate,
                >,
            >,
        ) -> Self {
            self.attribute_updates =
                input.map(|v| crate::constrained::MaybeConstrained::Constrained((v).into()));
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_attribute_updates(
            mut self,
            input: Option<impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::constrained::attribute_updates_constrained::AttributeUpdatesConstrained>>>,
        ) -> Self {
            self.attribute_updates = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expected(
            mut self,
            input: ::std::option::Option<
                ::std::collections::HashMap<
                    ::std::string::String,
                    crate::model::ExpectedAttributeValue,
                >,
            >,
        ) -> Self {
            self.expected =
                input.map(|v| crate::constrained::MaybeConstrained::Constrained((v).into()));
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_expected(
            mut self,
            input: Option<impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::constrained::expected_attribute_map_constrained::ExpectedAttributeMapConstrained>>>,
        ) -> Self {
            self.expected = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn conditional_operator(
            mut self,
            input: ::std::option::Option<crate::model::ConditionalOperator>,
        ) -> Self {
            self.conditional_operator =
                input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_conditional_operator(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::ConditionalOperator>,
                >,
            >,
        ) -> Self {
            self.conditional_operator = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn return_values(
            mut self,
            input: ::std::option::Option<crate::model::ReturnValue>,
        ) -> Self {
            self.return_values = input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_return_values(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::ReturnValue>,
                >,
            >,
        ) -> Self {
            self.return_values = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn return_consumed_capacity(
            mut self,
            input: ::std::option::Option<crate::model::ReturnConsumedCapacity>,
        ) -> Self {
            self.return_consumed_capacity =
                input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_return_consumed_capacity(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::ReturnConsumedCapacity>,
                >,
            >,
        ) -> Self {
            self.return_consumed_capacity = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn return_item_collection_metrics(
            mut self,
            input: ::std::option::Option<crate::model::ReturnItemCollectionMetrics>,
        ) -> Self {
            self.return_item_collection_metrics =
                input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_return_item_collection_metrics(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::ReturnItemCollectionMetrics>,
                >,
            >,
        ) -> Self {
            self.return_item_collection_metrics = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn update_expression(
            mut self,
            input: ::std::option::Option<::std::string::String>,
        ) -> Self {
            self.update_expression = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_update_expression(
            mut self,
            input: Option<impl ::std::convert::Into<::std::string::String>>,
        ) -> Self {
            self.update_expression = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn condition_expression(
            mut self,
            input: ::std::option::Option<::std::string::String>,
        ) -> Self {
            self.condition_expression = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_condition_expression(
            mut self,
            input: Option<impl ::std::convert::Into<::std::string::String>>,
        ) -> Self {
            self.condition_expression = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expression_attribute_names(
            mut self,
            input: ::std::option::Option<
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            >,
        ) -> Self {
            self.expression_attribute_names = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_expression_attribute_names(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                >,
            >,
        ) -> Self {
            self.expression_attribute_names = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expression_attribute_values(
            mut self,
            input: ::std::option::Option<
                ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.expression_attribute_values = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_expression_attribute_values(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        crate::model::AttributeValue,
                    >,
                >,
            >,
        ) -> Self {
            self.expression_attribute_values = input.map(|v| v.into());
            self
        }
        /// Consumes the builder and constructs a [`UpdateItemInput`](crate::input::UpdateItemInput).
        ///
        /// The builder fails to construct a [`UpdateItemInput`](crate::input::UpdateItemInput) if a [`ConstraintViolation`] occurs.
        ///
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::UpdateItemInput, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::input::UpdateItemInput, ConstraintViolation> {
            Ok(crate::input::UpdateItemInput {
                table_name: self
                    .table_name
                    .ok_or(ConstraintViolation::MissingTableName)?,
                key: self.key.ok_or(ConstraintViolation::MissingKey)?,
                attribute_updates: self
                    .attribute_updates
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| {
                        res.map(|v| v.into())
                            .map_err(ConstraintViolation::AttributeUpdates)
                    })
                    .transpose()?,
                expected: self
                    .expected
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map(|v| v.into()).map_err(ConstraintViolation::Expected))
                    .transpose()?,
                conditional_operator: self
                    .conditional_operator
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::ConditionalOperator))
                    .transpose()?,
                return_values: self
                    .return_values
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::ReturnValues))
                    .transpose()?,
                return_consumed_capacity: self
                    .return_consumed_capacity
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::ReturnConsumedCapacity))
                    .transpose()?,
                return_item_collection_metrics: self
                    .return_item_collection_metrics
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::ReturnItemCollectionMetrics))
                    .transpose()?,
                update_expression: self.update_expression,
                condition_expression: self.condition_expression,
                expression_attribute_names: self.expression_attribute_names,
                expression_attribute_values: self.expression_attribute_values,
            })
        }
    }
}
/// See [`CreateTableInput`](crate::input::CreateTableInput).
pub mod create_table_input {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `attribute_definitions` was not provided but it is required when building `CreateTableInput`.
        MissingAttributeDefinitions,
        /// Constraint violation occurred building member `attribute_definitions` when building `CreateTableInput`.
        #[doc(hidden)]
        AttributeDefinitions(crate::model::attribute_definitions::ConstraintViolation),
        /// `table_name` was not provided but it is required when building `CreateTableInput`.
        MissingTableName,
        /// `key_schema` was not provided but it is required when building `CreateTableInput`.
        MissingKeySchema,
        /// Constraint violation occurred building member `key_schema` when building `CreateTableInput`.
        #[doc(hidden)]
        KeySchema(crate::model::key_schema::ConstraintViolation),
        /// Constraint violation occurred building member `local_secondary_indexes` when building `CreateTableInput`.
        #[doc(hidden)]
        LocalSecondaryIndexes(crate::model::local_secondary_index_list::ConstraintViolation),
        /// Constraint violation occurred building member `global_secondary_indexes` when building `CreateTableInput`.
        #[doc(hidden)]
        GlobalSecondaryIndexes(crate::model::global_secondary_index_list::ConstraintViolation),
        /// Constraint violation occurred building member `billing_mode` when building `CreateTableInput`.
        #[doc(hidden)]
        BillingMode(crate::model::billing_mode::ConstraintViolation),
        /// Constraint violation occurred building member `provisioned_throughput` when building `CreateTableInput`.
        #[doc(hidden)]
        ProvisionedThroughput(crate::model::provisioned_throughput::ConstraintViolation),
        /// Constraint violation occurred building member `stream_specification` when building `CreateTableInput`.
        #[doc(hidden)]
        StreamSpecification(crate::model::stream_specification::ConstraintViolation),
        /// Constraint violation occurred building member `sse_specification` when building `CreateTableInput`.
        #[doc(hidden)]
        SseSpecification(crate::model::sse_specification::ConstraintViolation),
        /// Constraint violation occurred building member `tags` when building `CreateTableInput`.
        #[doc(hidden)]
        Tags(crate::model::tag_list::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingAttributeDefinitions => write!(f, "`attribute_definitions` was not provided but it is required when building `CreateTableInput`"),
                ConstraintViolation::AttributeDefinitions(_) => write!(f, "constraint violation occurred building member `attribute_definitions` when building `CreateTableInput`"),
                ConstraintViolation::MissingTableName => write!(f, "`table_name` was not provided but it is required when building `CreateTableInput`"),
                ConstraintViolation::MissingKeySchema => write!(f, "`key_schema` was not provided but it is required when building `CreateTableInput`"),
                ConstraintViolation::KeySchema(_) => write!(f, "constraint violation occurred building member `key_schema` when building `CreateTableInput`"),
                ConstraintViolation::LocalSecondaryIndexes(_) => write!(f, "constraint violation occurred building member `local_secondary_indexes` when building `CreateTableInput`"),
                ConstraintViolation::GlobalSecondaryIndexes(_) => write!(f, "constraint violation occurred building member `global_secondary_indexes` when building `CreateTableInput`"),
                ConstraintViolation::BillingMode(_) => write!(f, "constraint violation occurred building member `billing_mode` when building `CreateTableInput`"),
                ConstraintViolation::ProvisionedThroughput(_) => write!(f, "constraint violation occurred building member `provisioned_throughput` when building `CreateTableInput`"),
                ConstraintViolation::StreamSpecification(_) => write!(f, "constraint violation occurred building member `stream_specification` when building `CreateTableInput`"),
                ConstraintViolation::SseSpecification(_) => write!(f, "constraint violation occurred building member `sse_specification` when building `CreateTableInput`"),
                ConstraintViolation::Tags(_) => write!(f, "constraint violation occurred building member `tags` when building `CreateTableInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
        pub(crate) fn as_validation_exception_field(
            self,
            path: ::std::string::String,
        ) -> crate::model::ValidationExceptionField {
            match self {
            ConstraintViolation::MissingAttributeDefinitions => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/AttributeDefinitions' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/AttributeDefinitions",
                                            },
            ConstraintViolation::AttributeDefinitions(inner) => inner.as_validation_exception_field(path + "/AttributeDefinitions"),
            ConstraintViolation::MissingTableName => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/TableName' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/TableName",
                                            },
            ConstraintViolation::MissingKeySchema => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/KeySchema' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/KeySchema",
                                            },
            ConstraintViolation::KeySchema(inner) => inner.as_validation_exception_field(path + "/KeySchema"),
            ConstraintViolation::LocalSecondaryIndexes(inner) => inner.as_validation_exception_field(path + "/LocalSecondaryIndexes"),
            ConstraintViolation::GlobalSecondaryIndexes(inner) => inner.as_validation_exception_field(path + "/GlobalSecondaryIndexes"),
            ConstraintViolation::BillingMode(inner) => inner.as_validation_exception_field(path + "/BillingMode"),
            ConstraintViolation::ProvisionedThroughput(inner) => inner.as_validation_exception_field(path + "/ProvisionedThroughput"),
            ConstraintViolation::StreamSpecification(inner) => inner.as_validation_exception_field(path + "/StreamSpecification"),
            ConstraintViolation::SseSpecification(inner) => inner.as_validation_exception_field(path + "/SSESpecification"),
            ConstraintViolation::Tags(inner) => inner.as_validation_exception_field(path + "/Tags"),
        }
        }
    }
    impl ::std::convert::From<ConstraintViolation>
        for ::aws_smithy_http_server::protocol::aws_json::rejection::RequestRejection
    {
        fn from(constraint_violation: ConstraintViolation) -> Self {
            let first_validation_exception_field =
                constraint_violation.as_validation_exception_field("".to_owned());
            let validation_exception = crate::error::ValidationException {
                message: format!(
                    "1 validation error detected. {}",
                    &first_validation_exception_field.message
                ),
                field_list: Some(vec![first_validation_exception_field]),
            };
            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
        }
    }
    impl ::std::convert::From<Builder>
        for crate::constrained::MaybeConstrained<crate::input::CreateTableInput>
    {
        fn from(builder: Builder) -> Self {
            Self::Unconstrained(builder)
        }
    }
    impl ::std::convert::TryFrom<Builder> for crate::input::CreateTableInput {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> ::std::result::Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`CreateTableInput`](crate::input::CreateTableInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) attribute_definitions: ::std::option::Option<crate::constrained::MaybeConstrained<crate::constrained::attribute_definitions_constrained::AttributeDefinitionsConstrained>>,
        pub(crate) table_name: ::std::option::Option<::std::string::String>,
        pub(crate) key_schema: ::std::option::Option<crate::constrained::MaybeConstrained<crate::constrained::key_schema_constrained::KeySchemaConstrained>>,
        pub(crate) local_secondary_indexes: ::std::option::Option<crate::constrained::MaybeConstrained<crate::constrained::local_secondary_index_list_constrained::LocalSecondaryIndexListConstrained>>,
        pub(crate) global_secondary_indexes: ::std::option::Option<crate::constrained::MaybeConstrained<crate::constrained::global_secondary_index_list_constrained::GlobalSecondaryIndexListConstrained>>,
        pub(crate) billing_mode: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::BillingMode>>,
        pub(crate) provisioned_throughput: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ProvisionedThroughput>>,
        pub(crate) stream_specification: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::StreamSpecification>>,
        pub(crate) sse_specification: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::SseSpecification>>,
        pub(crate) tags: ::std::option::Option<crate::constrained::MaybeConstrained<crate::constrained::tag_list_constrained::TagListConstrained>>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn attribute_definitions(
            mut self,
            input: ::std::vec::Vec<crate::model::AttributeDefinition>,
        ) -> Self {
            self.attribute_definitions = Some(crate::constrained::MaybeConstrained::Constrained(
                (input).into(),
            ));
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_attribute_definitions(
            mut self,
            input: impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::constrained::attribute_definitions_constrained::AttributeDefinitionsConstrained>>,
        ) -> Self {
            self.attribute_definitions = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_name(mut self, input: ::std::string::String) -> Self {
            self.table_name = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_table_name(
            mut self,
            input: impl ::std::convert::Into<::std::string::String>,
        ) -> Self {
            self.table_name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn key_schema(
            mut self,
            input: ::std::vec::Vec<crate::model::KeySchemaElement>,
        ) -> Self {
            self.key_schema = Some(crate::constrained::MaybeConstrained::Constrained(
                (input).into(),
            ));
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_key_schema(
            mut self,
            input: impl ::std::convert::Into<
                crate::constrained::MaybeConstrained<
                    crate::constrained::key_schema_constrained::KeySchemaConstrained,
                >,
            >,
        ) -> Self {
            self.key_schema = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn local_secondary_indexes(
            mut self,
            input: ::std::option::Option<::std::vec::Vec<crate::model::LocalSecondaryIndex>>,
        ) -> Self {
            self.local_secondary_indexes =
                input.map(|v| crate::constrained::MaybeConstrained::Constrained((v).into()));
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_local_secondary_indexes(
            mut self,
            input: Option<impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::constrained::local_secondary_index_list_constrained::LocalSecondaryIndexListConstrained>>>,
        ) -> Self {
            self.local_secondary_indexes = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn global_secondary_indexes(
            mut self,
            input: ::std::option::Option<::std::vec::Vec<crate::model::GlobalSecondaryIndex>>,
        ) -> Self {
            self.global_secondary_indexes =
                input.map(|v| crate::constrained::MaybeConstrained::Constrained((v).into()));
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_global_secondary_indexes(
            mut self,
            input: Option<impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::constrained::global_secondary_index_list_constrained::GlobalSecondaryIndexListConstrained>>>,
        ) -> Self {
            self.global_secondary_indexes = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn billing_mode(
            mut self,
            input: ::std::option::Option<crate::model::BillingMode>,
        ) -> Self {
            self.billing_mode = input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_billing_mode(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::BillingMode>,
                >,
            >,
        ) -> Self {
            self.billing_mode = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn provisioned_throughput(
            mut self,
            input: ::std::option::Option<crate::model::ProvisionedThroughput>,
        ) -> Self {
            self.provisioned_throughput =
                input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_provisioned_throughput(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::ProvisionedThroughput>,
                >,
            >,
        ) -> Self {
            self.provisioned_throughput = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn stream_specification(
            mut self,
            input: ::std::option::Option<crate::model::StreamSpecification>,
        ) -> Self {
            self.stream_specification =
                input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_stream_specification(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::StreamSpecification>,
                >,
            >,
        ) -> Self {
            self.stream_specification = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn sse_specification(
            mut self,
            input: ::std::option::Option<crate::model::SseSpecification>,
        ) -> Self {
            self.sse_specification = input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_sse_specification(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::SseSpecification>,
                >,
            >,
        ) -> Self {
            self.sse_specification = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn tags(
            mut self,
            input: ::std::option::Option<::std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags =
                input.map(|v| crate::constrained::MaybeConstrained::Constrained((v).into()));
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_tags(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<
                        crate::constrained::tag_list_constrained::TagListConstrained,
                    >,
                >,
            >,
        ) -> Self {
            self.tags = input.map(|v| v.into());
            self
        }
        /// Consumes the builder and constructs a [`CreateTableInput`](crate::input::CreateTableInput).
        ///
        /// The builder fails to construct a [`CreateTableInput`](crate::input::CreateTableInput) if a [`ConstraintViolation`] occurs.
        ///
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::CreateTableInput, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::input::CreateTableInput, ConstraintViolation> {
            Ok(crate::input::CreateTableInput {
                attribute_definitions: self
                    .attribute_definitions
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| {
                        res.map(|v| v.into())
                            .map_err(ConstraintViolation::AttributeDefinitions)
                    })
                    .transpose()?
                    .ok_or(ConstraintViolation::MissingAttributeDefinitions)?,
                table_name: self
                    .table_name
                    .ok_or(ConstraintViolation::MissingTableName)?,
                key_schema: self
                    .key_schema
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| {
                        res.map(|v| v.into())
                            .map_err(ConstraintViolation::KeySchema)
                    })
                    .transpose()?
                    .ok_or(ConstraintViolation::MissingKeySchema)?,
                local_secondary_indexes: self
                    .local_secondary_indexes
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| {
                        res.map(|v| v.into())
                            .map_err(ConstraintViolation::LocalSecondaryIndexes)
                    })
                    .transpose()?,
                global_secondary_indexes: self
                    .global_secondary_indexes
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| {
                        res.map(|v| v.into())
                            .map_err(ConstraintViolation::GlobalSecondaryIndexes)
                    })
                    .transpose()?,
                billing_mode: self
                    .billing_mode
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::BillingMode))
                    .transpose()?,
                provisioned_throughput: self
                    .provisioned_throughput
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::ProvisionedThroughput))
                    .transpose()?,
                stream_specification: self
                    .stream_specification
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::StreamSpecification))
                    .transpose()?,
                sse_specification: self
                    .sse_specification
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::SseSpecification))
                    .transpose()?,
                tags: self
                    .tags
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map(|v| v.into()).map_err(ConstraintViolation::Tags))
                    .transpose()?,
            })
        }
    }
}
/// See [`PutItemInput`](crate::input::PutItemInput).
pub mod put_item_input {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `table_name` was not provided but it is required when building `PutItemInput`.
        MissingTableName,
        /// `item` was not provided but it is required when building `PutItemInput`.
        MissingItem,
        /// Constraint violation occurred building member `expected` when building `PutItemInput`.
        #[doc(hidden)]
        Expected(crate::model::expected_attribute_map::ConstraintViolation),
        /// Constraint violation occurred building member `return_values` when building `PutItemInput`.
        #[doc(hidden)]
        ReturnValues(crate::model::return_value::ConstraintViolation),
        /// Constraint violation occurred building member `return_consumed_capacity` when building `PutItemInput`.
        #[doc(hidden)]
        ReturnConsumedCapacity(crate::model::return_consumed_capacity::ConstraintViolation),
        /// Constraint violation occurred building member `return_item_collection_metrics` when building `PutItemInput`.
        #[doc(hidden)]
        ReturnItemCollectionMetrics(
            crate::model::return_item_collection_metrics::ConstraintViolation,
        ),
        /// Constraint violation occurred building member `conditional_operator` when building `PutItemInput`.
        #[doc(hidden)]
        ConditionalOperator(crate::model::conditional_operator::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingTableName => write!(f, "`table_name` was not provided but it is required when building `PutItemInput`"),
                ConstraintViolation::MissingItem => write!(f, "`item` was not provided but it is required when building `PutItemInput`"),
                ConstraintViolation::Expected(_) => write!(f, "constraint violation occurred building member `expected` when building `PutItemInput`"),
                ConstraintViolation::ReturnValues(_) => write!(f, "constraint violation occurred building member `return_values` when building `PutItemInput`"),
                ConstraintViolation::ReturnConsumedCapacity(_) => write!(f, "constraint violation occurred building member `return_consumed_capacity` when building `PutItemInput`"),
                ConstraintViolation::ReturnItemCollectionMetrics(_) => write!(f, "constraint violation occurred building member `return_item_collection_metrics` when building `PutItemInput`"),
                ConstraintViolation::ConditionalOperator(_) => write!(f, "constraint violation occurred building member `conditional_operator` when building `PutItemInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
        pub(crate) fn as_validation_exception_field(
            self,
            path: ::std::string::String,
        ) -> crate::model::ValidationExceptionField {
            match self {
            ConstraintViolation::MissingTableName => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/TableName' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/TableName",
                                            },
            ConstraintViolation::MissingItem => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/Item' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/Item",
                                            },
            ConstraintViolation::Expected(inner) => inner.as_validation_exception_field(path + "/Expected"),
            ConstraintViolation::ReturnValues(inner) => inner.as_validation_exception_field(path + "/ReturnValues"),
            ConstraintViolation::ReturnConsumedCapacity(inner) => inner.as_validation_exception_field(path + "/ReturnConsumedCapacity"),
            ConstraintViolation::ReturnItemCollectionMetrics(inner) => inner.as_validation_exception_field(path + "/ReturnItemCollectionMetrics"),
            ConstraintViolation::ConditionalOperator(inner) => inner.as_validation_exception_field(path + "/ConditionalOperator"),
        }
        }
    }
    impl ::std::convert::From<ConstraintViolation>
        for ::aws_smithy_http_server::protocol::aws_json::rejection::RequestRejection
    {
        fn from(constraint_violation: ConstraintViolation) -> Self {
            let first_validation_exception_field =
                constraint_violation.as_validation_exception_field("".to_owned());
            let validation_exception = crate::error::ValidationException {
                message: format!(
                    "1 validation error detected. {}",
                    &first_validation_exception_field.message
                ),
                field_list: Some(vec![first_validation_exception_field]),
            };
            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
        }
    }
    impl ::std::convert::From<Builder>
        for crate::constrained::MaybeConstrained<crate::input::PutItemInput>
    {
        fn from(builder: Builder) -> Self {
            Self::Unconstrained(builder)
        }
    }
    impl ::std::convert::TryFrom<Builder> for crate::input::PutItemInput {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> ::std::result::Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`PutItemInput`](crate::input::PutItemInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: ::std::option::Option<::std::string::String>,
        pub(crate) item: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>,
        pub(crate) expected: ::std::option::Option<crate::constrained::MaybeConstrained<crate::constrained::expected_attribute_map_constrained::ExpectedAttributeMapConstrained>>,
        pub(crate) return_values: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ReturnValue>>,
        pub(crate) return_consumed_capacity: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ReturnConsumedCapacity>>,
        pub(crate) return_item_collection_metrics: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ReturnItemCollectionMetrics>>,
        pub(crate) conditional_operator: ::std::option::Option<crate::constrained::MaybeConstrained<crate::model::ConditionalOperator>>,
        pub(crate) condition_expression: ::std::option::Option<::std::string::String>,
        pub(crate) expression_attribute_names: ::std::option::Option<::std::collections::HashMap::<::std::string::String, ::std::string::String>>,
        pub(crate) expression_attribute_values: ::std::option::Option<::std::collections::HashMap::<::std::string::String, crate::model::AttributeValue>>,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_name(mut self, input: ::std::string::String) -> Self {
            self.table_name = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_table_name(
            mut self,
            input: impl ::std::convert::Into<::std::string::String>,
        ) -> Self {
            self.table_name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn item(
            mut self,
            input: ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
        ) -> Self {
            self.item = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_item(
            mut self,
            input: impl ::std::convert::Into<
                ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.item = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expected(
            mut self,
            input: ::std::option::Option<
                ::std::collections::HashMap<
                    ::std::string::String,
                    crate::model::ExpectedAttributeValue,
                >,
            >,
        ) -> Self {
            self.expected =
                input.map(|v| crate::constrained::MaybeConstrained::Constrained((v).into()));
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_expected(
            mut self,
            input: Option<impl ::std::convert::Into<crate::constrained::MaybeConstrained<crate::constrained::expected_attribute_map_constrained::ExpectedAttributeMapConstrained>>>,
        ) -> Self {
            self.expected = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn return_values(
            mut self,
            input: ::std::option::Option<crate::model::ReturnValue>,
        ) -> Self {
            self.return_values = input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_return_values(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::ReturnValue>,
                >,
            >,
        ) -> Self {
            self.return_values = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn return_consumed_capacity(
            mut self,
            input: ::std::option::Option<crate::model::ReturnConsumedCapacity>,
        ) -> Self {
            self.return_consumed_capacity =
                input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_return_consumed_capacity(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::ReturnConsumedCapacity>,
                >,
            >,
        ) -> Self {
            self.return_consumed_capacity = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn return_item_collection_metrics(
            mut self,
            input: ::std::option::Option<crate::model::ReturnItemCollectionMetrics>,
        ) -> Self {
            self.return_item_collection_metrics =
                input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_return_item_collection_metrics(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::ReturnItemCollectionMetrics>,
                >,
            >,
        ) -> Self {
            self.return_item_collection_metrics = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn conditional_operator(
            mut self,
            input: ::std::option::Option<crate::model::ConditionalOperator>,
        ) -> Self {
            self.conditional_operator =
                input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_conditional_operator(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::ConditionalOperator>,
                >,
            >,
        ) -> Self {
            self.conditional_operator = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn condition_expression(
            mut self,
            input: ::std::option::Option<::std::string::String>,
        ) -> Self {
            self.condition_expression = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_condition_expression(
            mut self,
            input: Option<impl ::std::convert::Into<::std::string::String>>,
        ) -> Self {
            self.condition_expression = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expression_attribute_names(
            mut self,
            input: ::std::option::Option<
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            >,
        ) -> Self {
            self.expression_attribute_names = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_expression_attribute_names(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                >,
            >,
        ) -> Self {
            self.expression_attribute_names = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expression_attribute_values(
            mut self,
            input: ::std::option::Option<
                ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.expression_attribute_values = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_expression_attribute_values(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        crate::model::AttributeValue,
                    >,
                >,
            >,
        ) -> Self {
            self.expression_attribute_values = input.map(|v| v.into());
            self
        }
        /// Consumes the builder and constructs a [`PutItemInput`](crate::input::PutItemInput).
        ///
        /// The builder fails to construct a [`PutItemInput`](crate::input::PutItemInput) if a [`ConstraintViolation`] occurs.
        ///
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::PutItemInput, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::input::PutItemInput, ConstraintViolation> {
            Ok(crate::input::PutItemInput {
                table_name: self
                    .table_name
                    .ok_or(ConstraintViolation::MissingTableName)?,
                item: self.item.ok_or(ConstraintViolation::MissingItem)?,
                expected: self
                    .expected
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map(|v| v.into()).map_err(ConstraintViolation::Expected))
                    .transpose()?,
                return_values: self
                    .return_values
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::ReturnValues))
                    .transpose()?,
                return_consumed_capacity: self
                    .return_consumed_capacity
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::ReturnConsumedCapacity))
                    .transpose()?,
                return_item_collection_metrics: self
                    .return_item_collection_metrics
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::ReturnItemCollectionMetrics))
                    .transpose()?,
                conditional_operator: self
                    .conditional_operator
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::ConditionalOperator))
                    .transpose()?,
                condition_expression: self.condition_expression,
                expression_attribute_names: self.expression_attribute_names,
                expression_attribute_values: self.expression_attribute_values,
            })
        }
    }
}
/// See [`GetItemInput`](crate::input::GetItemInput).
pub mod get_item_input {

    #[derive(::std::cmp::PartialEq, ::std::fmt::Debug)]
    /// Holds one variant for each of the ways the builder can fail.
    #[non_exhaustive]
    #[allow(clippy::enum_variant_names)]
    pub enum ConstraintViolation {
        /// `table_name` was not provided but it is required when building `GetItemInput`.
        MissingTableName,
        /// `key` was not provided but it is required when building `GetItemInput`.
        MissingKey,
        /// Constraint violation occurred building member `return_consumed_capacity` when building `GetItemInput`.
        #[doc(hidden)]
        ReturnConsumedCapacity(crate::model::return_consumed_capacity::ConstraintViolation),
    }
    impl ::std::fmt::Display for ConstraintViolation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ConstraintViolation::MissingTableName => write!(f, "`table_name` was not provided but it is required when building `GetItemInput`"),
                ConstraintViolation::MissingKey => write!(f, "`key` was not provided but it is required when building `GetItemInput`"),
                ConstraintViolation::ReturnConsumedCapacity(_) => write!(f, "constraint violation occurred building member `return_consumed_capacity` when building `GetItemInput`"),
            }
        }
    }
    impl ::std::error::Error for ConstraintViolation {}
    impl ConstraintViolation {
        pub(crate) fn as_validation_exception_field(
            self,
            path: ::std::string::String,
        ) -> crate::model::ValidationExceptionField {
            match self {
            ConstraintViolation::MissingTableName => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/TableName' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/TableName",
                                            },
            ConstraintViolation::MissingKey => crate::model::ValidationExceptionField {
                                                message: format!("Value at '{}/Key' failed to satisfy constraint: Member must not be null", path),
                                                path: path + "/Key",
                                            },
            ConstraintViolation::ReturnConsumedCapacity(inner) => inner.as_validation_exception_field(path + "/ReturnConsumedCapacity"),
        }
        }
    }
    impl ::std::convert::From<ConstraintViolation>
        for ::aws_smithy_http_server::protocol::aws_json::rejection::RequestRejection
    {
        fn from(constraint_violation: ConstraintViolation) -> Self {
            let first_validation_exception_field =
                constraint_violation.as_validation_exception_field("".to_owned());
            let validation_exception = crate::error::ValidationException {
                message: format!(
                    "1 validation error detected. {}",
                    &first_validation_exception_field.message
                ),
                field_list: Some(vec![first_validation_exception_field]),
            };
            Self::ConstraintViolation(
                                crate::protocol_serde::shape_validation_exception::ser_validation_exception_error(&validation_exception)
                                    .expect("validation exceptions should never fail to serialize; please file a bug report under https://github.com/smithy-lang/smithy-rs/issues")
                            )
        }
    }
    impl ::std::convert::From<Builder>
        for crate::constrained::MaybeConstrained<crate::input::GetItemInput>
    {
        fn from(builder: Builder) -> Self {
            Self::Unconstrained(builder)
        }
    }
    impl ::std::convert::TryFrom<Builder> for crate::input::GetItemInput {
        type Error = ConstraintViolation;

        fn try_from(builder: Builder) -> ::std::result::Result<Self, Self::Error> {
            builder.build()
        }
    }
    /// A builder for [`GetItemInput`](crate::input::GetItemInput).
    #[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
    pub struct Builder {
        pub(crate) table_name: ::std::option::Option<::std::string::String>,
        pub(crate) key: ::std::option::Option<
            ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
        >,
        pub(crate) attributes_to_get: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        pub(crate) consistent_read: ::std::option::Option<bool>,
        pub(crate) return_consumed_capacity: ::std::option::Option<
            crate::constrained::MaybeConstrained<crate::model::ReturnConsumedCapacity>,
        >,
        pub(crate) projection_expression: ::std::option::Option<::std::string::String>,
        pub(crate) expression_attribute_names: ::std::option::Option<
            ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        >,
    }
    impl Builder {
        #[allow(missing_docs)] // documentation missing in model
        pub fn table_name(mut self, input: ::std::string::String) -> Self {
            self.table_name = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_table_name(
            mut self,
            input: impl ::std::convert::Into<::std::string::String>,
        ) -> Self {
            self.table_name = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn key(
            mut self,
            input: ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
        ) -> Self {
            self.key = Some(input);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_key(
            mut self,
            input: impl ::std::convert::Into<
                ::std::collections::HashMap<::std::string::String, crate::model::AttributeValue>,
            >,
        ) -> Self {
            self.key = Some(input.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn attributes_to_get(
            mut self,
            input: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
        ) -> Self {
            self.attributes_to_get = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_attributes_to_get(
            mut self,
            input: Option<impl ::std::convert::Into<::std::vec::Vec<::std::string::String>>>,
        ) -> Self {
            self.attributes_to_get = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn consistent_read(mut self, input: ::std::option::Option<bool>) -> Self {
            self.consistent_read = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_consistent_read(
            mut self,
            input: Option<impl ::std::convert::Into<bool>>,
        ) -> Self {
            self.consistent_read = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn return_consumed_capacity(
            mut self,
            input: ::std::option::Option<crate::model::ReturnConsumedCapacity>,
        ) -> Self {
            self.return_consumed_capacity =
                input.map(crate::constrained::MaybeConstrained::Constrained);
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_return_consumed_capacity(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    crate::constrained::MaybeConstrained<crate::model::ReturnConsumedCapacity>,
                >,
            >,
        ) -> Self {
            self.return_consumed_capacity = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn projection_expression(
            mut self,
            input: ::std::option::Option<::std::string::String>,
        ) -> Self {
            self.projection_expression = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_projection_expression(
            mut self,
            input: Option<impl ::std::convert::Into<::std::string::String>>,
        ) -> Self {
            self.projection_expression = input.map(|v| v.into());
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub fn expression_attribute_names(
            mut self,
            input: ::std::option::Option<
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            >,
        ) -> Self {
            self.expression_attribute_names = input;
            self
        }
        #[allow(missing_docs)] // documentation missing in model
        pub(crate) fn set_expression_attribute_names(
            mut self,
            input: Option<
                impl ::std::convert::Into<
                    ::std::collections::HashMap<::std::string::String, ::std::string::String>,
                >,
            >,
        ) -> Self {
            self.expression_attribute_names = input.map(|v| v.into());
            self
        }
        /// Consumes the builder and constructs a [`GetItemInput`](crate::input::GetItemInput).
        ///
        /// The builder fails to construct a [`GetItemInput`](crate::input::GetItemInput) if a [`ConstraintViolation`] occurs.
        ///
        /// If the builder fails, it will return the _first_ encountered [`ConstraintViolation`].
        pub fn build(self) -> Result<crate::input::GetItemInput, ConstraintViolation> {
            self.build_enforcing_all_constraints()
        }
        fn build_enforcing_all_constraints(
            self,
        ) -> Result<crate::input::GetItemInput, ConstraintViolation> {
            Ok(crate::input::GetItemInput {
                table_name: self
                    .table_name
                    .ok_or(ConstraintViolation::MissingTableName)?,
                key: self.key.ok_or(ConstraintViolation::MissingKey)?,
                attributes_to_get: self.attributes_to_get,
                consistent_read: self.consistent_read,
                return_consumed_capacity: self
                    .return_consumed_capacity
                    .map(|v| match v {
                        crate::constrained::MaybeConstrained::Constrained(x) => Ok(x),
                        crate::constrained::MaybeConstrained::Unconstrained(x) => x.try_into(),
                    })
                    .map(|res| res.map_err(ConstraintViolation::ReturnConsumedCapacity))
                    .transpose()?,
                projection_expression: self.projection_expression,
                expression_attribute_names: self.expression_attribute_names,
            })
        }
    }
}
