// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.













pub(crate) mod expected_attribute_map_unconstrained {
    
    #[derive(Debug, Clone)]
                    pub(crate) struct ExpectedAttributeMapUnconstrained(pub(crate) std::collections::HashMap<::std::string::String, crate::model::expected_attribute_value::Builder>);
    
                    impl From<ExpectedAttributeMapUnconstrained> for crate::constrained::MaybeConstrained<crate::constrained::expected_attribute_map_constrained::ExpectedAttributeMapConstrained> {
                        fn from(value: ExpectedAttributeMapUnconstrained) -> Self {
                            Self::Unconstrained(value)
                        }
                    }
    impl std::convert::TryFrom<ExpectedAttributeMapUnconstrained> for crate::constrained::expected_attribute_map_constrained::ExpectedAttributeMapConstrained {
        type Error = crate::model::expected_attribute_map::ConstraintViolation;
        fn try_from(value: ExpectedAttributeMapUnconstrained) -> std::result::Result<Self, Self::Error> {
            let res: ::std::result::Result<::std::collections::HashMap<::std::string::String, crate::model::ExpectedAttributeValue>, Self::Error> = value.0
                                        .into_iter()
                                        .map(|(k, v)| {
                                            match crate::model::ExpectedAttributeValue::try_from(v) {
                                                    Ok(v) => Ok((k, v)),
                                                    Err(inner_constraint_violation) => Err(Self::Error::Value(k, inner_constraint_violation)),
                                                }
                                        })
                                        .collect();
                                    let hm = res?;
            Ok(Self(hm))
        }
    }
    
    
    
    
}
pub(crate) mod attribute_updates_unconstrained {
    
    #[derive(Debug, Clone)]
                    pub(crate) struct AttributeUpdatesUnconstrained(pub(crate) std::collections::HashMap<::std::string::String, crate::model::attribute_value_update::Builder>);
    
                    impl From<AttributeUpdatesUnconstrained> for crate::constrained::MaybeConstrained<crate::constrained::attribute_updates_constrained::AttributeUpdatesConstrained> {
                        fn from(value: AttributeUpdatesUnconstrained) -> Self {
                            Self::Unconstrained(value)
                        }
                    }
    impl std::convert::TryFrom<AttributeUpdatesUnconstrained> for crate::constrained::attribute_updates_constrained::AttributeUpdatesConstrained {
        type Error = crate::model::attribute_updates::ConstraintViolation;
        fn try_from(value: AttributeUpdatesUnconstrained) -> std::result::Result<Self, Self::Error> {
            let res: ::std::result::Result<::std::collections::HashMap<::std::string::String, crate::model::AttributeValueUpdate>, Self::Error> = value.0
                                        .into_iter()
                                        .map(|(k, v)| {
                                            match crate::model::AttributeValueUpdate::try_from(v) {
                                                    Ok(v) => Ok((k, v)),
                                                    Err(inner_constraint_violation) => Err(Self::Error::Value(k, inner_constraint_violation)),
                                                }
                                        })
                                        .collect();
                                    let hm = res?;
            Ok(Self(hm))
        }
    }
    
    
    
    
}
pub(crate) mod key_schema_unconstrained {
    
    #[derive(Debug, Clone)]
                    pub(crate) struct KeySchemaUnconstrained(pub(crate) std::vec::Vec<crate::model::key_schema_element::Builder>);
    
                    impl From<KeySchemaUnconstrained> for crate::constrained::MaybeConstrained<crate::constrained::key_schema_constrained::KeySchemaConstrained> {
                        fn from(value: KeySchemaUnconstrained) -> Self {
                            Self::Unconstrained(value)
                        }
                    }
    impl std::convert::TryFrom<KeySchemaUnconstrained> for crate::constrained::key_schema_constrained::KeySchemaConstrained {
        type Error = crate::model::key_schema::ConstraintViolation;
        fn try_from(value: KeySchemaUnconstrained) -> std::result::Result<Self, Self::Error> {
            let res: ::std::result::Result<::std::vec::Vec<crate::model::KeySchemaElement>, (usize, crate::model::key_schema_element::ConstraintViolation) > = value
                                        .0
                                        .into_iter()
                                        .enumerate()
                                        .map(|(idx, inner)| {
                                            inner.try_into().map_err(|inner_violation| (idx, inner_violation))
                                        })
                                        .collect();
                                    let inner = res
                                        
                                        .map_err(|(idx, inner_violation)| Self::Error::Member(idx, inner_violation))?;
            Ok(Self(inner))
        }
    }
    
    
    
    
}
pub(crate) mod attribute_definitions_unconstrained {
    
    #[derive(Debug, Clone)]
                    pub(crate) struct AttributeDefinitionsUnconstrained(pub(crate) std::vec::Vec<crate::model::attribute_definition::Builder>);
    
                    impl From<AttributeDefinitionsUnconstrained> for crate::constrained::MaybeConstrained<crate::constrained::attribute_definitions_constrained::AttributeDefinitionsConstrained> {
                        fn from(value: AttributeDefinitionsUnconstrained) -> Self {
                            Self::Unconstrained(value)
                        }
                    }
    impl std::convert::TryFrom<AttributeDefinitionsUnconstrained> for crate::constrained::attribute_definitions_constrained::AttributeDefinitionsConstrained {
        type Error = crate::model::attribute_definitions::ConstraintViolation;
        fn try_from(value: AttributeDefinitionsUnconstrained) -> std::result::Result<Self, Self::Error> {
            let res: ::std::result::Result<::std::vec::Vec<crate::model::AttributeDefinition>, (usize, crate::model::attribute_definition::ConstraintViolation) > = value
                                        .0
                                        .into_iter()
                                        .enumerate()
                                        .map(|(idx, inner)| {
                                            inner.try_into().map_err(|inner_violation| (idx, inner_violation))
                                        })
                                        .collect();
                                    let inner = res
                                        
                                        .map_err(|(idx, inner_violation)| Self::Error::Member(idx, inner_violation))?;
            Ok(Self(inner))
        }
    }
    
    
    
    
}
pub(crate) mod tag_list_unconstrained {
    
    #[derive(Debug, Clone)]
                    pub(crate) struct TagListUnconstrained(pub(crate) std::vec::Vec<crate::model::tag::Builder>);
    
                    impl From<TagListUnconstrained> for crate::constrained::MaybeConstrained<crate::constrained::tag_list_constrained::TagListConstrained> {
                        fn from(value: TagListUnconstrained) -> Self {
                            Self::Unconstrained(value)
                        }
                    }
    impl std::convert::TryFrom<TagListUnconstrained> for crate::constrained::tag_list_constrained::TagListConstrained {
        type Error = crate::model::tag_list::ConstraintViolation;
        fn try_from(value: TagListUnconstrained) -> std::result::Result<Self, Self::Error> {
            let res: ::std::result::Result<::std::vec::Vec<crate::model::Tag>, (usize, crate::model::tag::ConstraintViolation) > = value
                                        .0
                                        .into_iter()
                                        .enumerate()
                                        .map(|(idx, inner)| {
                                            inner.try_into().map_err(|inner_violation| (idx, inner_violation))
                                        })
                                        .collect();
                                    let inner = res
                                        
                                        .map_err(|(idx, inner_violation)| Self::Error::Member(idx, inner_violation))?;
            Ok(Self(inner))
        }
    }
    
    
    
    
}
pub(crate) mod global_secondary_index_list_unconstrained {
    
    #[derive(Debug, Clone)]
                    pub(crate) struct GlobalSecondaryIndexListUnconstrained(pub(crate) std::vec::Vec<crate::model::global_secondary_index::Builder>);
    
                    impl From<GlobalSecondaryIndexListUnconstrained> for crate::constrained::MaybeConstrained<crate::constrained::global_secondary_index_list_constrained::GlobalSecondaryIndexListConstrained> {
                        fn from(value: GlobalSecondaryIndexListUnconstrained) -> Self {
                            Self::Unconstrained(value)
                        }
                    }
    impl std::convert::TryFrom<GlobalSecondaryIndexListUnconstrained> for crate::constrained::global_secondary_index_list_constrained::GlobalSecondaryIndexListConstrained {
        type Error = crate::model::global_secondary_index_list::ConstraintViolation;
        fn try_from(value: GlobalSecondaryIndexListUnconstrained) -> std::result::Result<Self, Self::Error> {
            let res: ::std::result::Result<::std::vec::Vec<crate::model::GlobalSecondaryIndex>, (usize, crate::model::global_secondary_index::ConstraintViolation) > = value
                                        .0
                                        .into_iter()
                                        .enumerate()
                                        .map(|(idx, inner)| {
                                            inner.try_into().map_err(|inner_violation| (idx, inner_violation))
                                        })
                                        .collect();
                                    let inner = res
                                        
                                        .map_err(|(idx, inner_violation)| Self::Error::Member(idx, inner_violation))?;
            Ok(Self(inner))
        }
    }
    
    
    
    
}
pub(crate) mod local_secondary_index_list_unconstrained {
    
    #[derive(Debug, Clone)]
                    pub(crate) struct LocalSecondaryIndexListUnconstrained(pub(crate) std::vec::Vec<crate::model::local_secondary_index::Builder>);
    
                    impl From<LocalSecondaryIndexListUnconstrained> for crate::constrained::MaybeConstrained<crate::constrained::local_secondary_index_list_constrained::LocalSecondaryIndexListConstrained> {
                        fn from(value: LocalSecondaryIndexListUnconstrained) -> Self {
                            Self::Unconstrained(value)
                        }
                    }
    impl std::convert::TryFrom<LocalSecondaryIndexListUnconstrained> for crate::constrained::local_secondary_index_list_constrained::LocalSecondaryIndexListConstrained {
        type Error = crate::model::local_secondary_index_list::ConstraintViolation;
        fn try_from(value: LocalSecondaryIndexListUnconstrained) -> std::result::Result<Self, Self::Error> {
            let res: ::std::result::Result<::std::vec::Vec<crate::model::LocalSecondaryIndex>, (usize, crate::model::local_secondary_index::ConstraintViolation) > = value
                                        .0
                                        .into_iter()
                                        .enumerate()
                                        .map(|(idx, inner)| {
                                            inner.try_into().map_err(|inner_violation| (idx, inner_violation))
                                        })
                                        .collect();
                                    let inner = res
                                        
                                        .map_err(|(idx, inner_violation)| Self::Error::Member(idx, inner_violation))?;
            Ok(Self(inner))
        }
    }
    
    
    
    
}

