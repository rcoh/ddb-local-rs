// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
::pin_project_lite::pin_project! {
                /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
                /// [`UpdateItemInput`](crate::input::UpdateItemInput) using modelled bindings.
                pub struct UpdateItemInputFuture {
                    inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::UpdateItemInput, ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError>> + Send>>
                }
            }

            impl std::future::Future for UpdateItemInputFuture {
                type Output = Result<crate::input::UpdateItemInput, ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError>;

                fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
                    let this = self.project();
                    this.inner.as_mut().poll(cx)
                }
            }

            impl<B> ::aws_smithy_legacy_http_server::request::FromRequest<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0, B> for crate::input::UpdateItemInput
            where
                B: ::aws_smithy_legacy_http_server::body::HttpBody + Send,
                B: 'static,
                
                B::Data: Send,
                ::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection : From<<B as ::aws_smithy_legacy_http_server::body::HttpBody>::Error>
            {
                type Rejection = ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError;
                type Future = UpdateItemInputFuture;

                fn from_request(request: ::http::Request<B>) -> Self::Future {
                    let fut = async move {
                        if !::aws_smithy_legacy_http_server::protocol::accept_header_classifier(request.headers(), &crate::mimes::CONTENT_TYPE_APPLICATION_X_AMZ_JSON_1_0) {
                                return Err(::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection::NotAcceptable);
                            }
                        crate::protocol_serde::shape_update_item::de_update_item_http_request(request)
                            .await
                    };
                    use ::futures_util::future::TryFutureExt;
                    let fut = fut.map_err(|e: ::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection| {
                        ::tracing::debug!(error = %e, "failed to deserialize request");
                        ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e)
                    });
                    UpdateItemInputFuture {
                        inner: Box::pin(fut)
                    }
                }
            }
impl ::aws_smithy_legacy_http_server::response::IntoResponse<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0> for crate::output::UpdateItemOutput {
                fn into_response(self) -> ::aws_smithy_legacy_http_server::response::Response {
                    match crate::protocol_serde::shape_update_item::ser_update_item_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_legacy_http_server::response::IntoResponse::<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0>::into_response(::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e))
                        }
                    }
                }
            }
impl ::aws_smithy_legacy_http_server::response::IntoResponse<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0> for crate::error::UpdateItemError {
    fn into_response(self) -> ::aws_smithy_legacy_http_server::response::Response {
        match crate::protocol_serde::shape_update_item::ser_update_item_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(::aws_smithy_legacy_http_server::extension::ModeledErrorExtension::new(self.name()));
                response
            },
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_legacy_http_server::response::IntoResponse::<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0>::into_response(::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e))
            }
        }
    }
}


::pin_project_lite::pin_project! {
                /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
                /// [`CreateTableInput`](crate::input::CreateTableInput) using modelled bindings.
                pub struct CreateTableInputFuture {
                    inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::CreateTableInput, ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError>> + Send>>
                }
            }

            impl std::future::Future for CreateTableInputFuture {
                type Output = Result<crate::input::CreateTableInput, ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError>;

                fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
                    let this = self.project();
                    this.inner.as_mut().poll(cx)
                }
            }

            impl<B> ::aws_smithy_legacy_http_server::request::FromRequest<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0, B> for crate::input::CreateTableInput
            where
                B: ::aws_smithy_legacy_http_server::body::HttpBody + Send,
                B: 'static,
                
                B::Data: Send,
                ::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection : From<<B as ::aws_smithy_legacy_http_server::body::HttpBody>::Error>
            {
                type Rejection = ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError;
                type Future = CreateTableInputFuture;

                fn from_request(request: ::http::Request<B>) -> Self::Future {
                    let fut = async move {
                        if !::aws_smithy_legacy_http_server::protocol::accept_header_classifier(request.headers(), &crate::mimes::CONTENT_TYPE_APPLICATION_X_AMZ_JSON_1_0) {
                                return Err(::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection::NotAcceptable);
                            }
                        crate::protocol_serde::shape_create_table::de_create_table_http_request(request)
                            .await
                    };
                    use ::futures_util::future::TryFutureExt;
                    let fut = fut.map_err(|e: ::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection| {
                        ::tracing::debug!(error = %e, "failed to deserialize request");
                        ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e)
                    });
                    CreateTableInputFuture {
                        inner: Box::pin(fut)
                    }
                }
            }
impl ::aws_smithy_legacy_http_server::response::IntoResponse<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0> for crate::output::CreateTableOutput {
                fn into_response(self) -> ::aws_smithy_legacy_http_server::response::Response {
                    match crate::protocol_serde::shape_create_table::ser_create_table_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_legacy_http_server::response::IntoResponse::<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0>::into_response(::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e))
                        }
                    }
                }
            }
impl ::aws_smithy_legacy_http_server::response::IntoResponse<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0> for crate::error::CreateTableError {
    fn into_response(self) -> ::aws_smithy_legacy_http_server::response::Response {
        match crate::protocol_serde::shape_create_table::ser_create_table_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(::aws_smithy_legacy_http_server::extension::ModeledErrorExtension::new(self.name()));
                response
            },
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_legacy_http_server::response::IntoResponse::<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0>::into_response(::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e))
            }
        }
    }
}


::pin_project_lite::pin_project! {
                /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
                /// [`PutItemInput`](crate::input::PutItemInput) using modelled bindings.
                pub struct PutItemInputFuture {
                    inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::PutItemInput, ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError>> + Send>>
                }
            }

            impl std::future::Future for PutItemInputFuture {
                type Output = Result<crate::input::PutItemInput, ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError>;

                fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
                    let this = self.project();
                    this.inner.as_mut().poll(cx)
                }
            }

            impl<B> ::aws_smithy_legacy_http_server::request::FromRequest<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0, B> for crate::input::PutItemInput
            where
                B: ::aws_smithy_legacy_http_server::body::HttpBody + Send,
                B: 'static,
                
                B::Data: Send,
                ::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection : From<<B as ::aws_smithy_legacy_http_server::body::HttpBody>::Error>
            {
                type Rejection = ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError;
                type Future = PutItemInputFuture;

                fn from_request(request: ::http::Request<B>) -> Self::Future {
                    let fut = async move {
                        if !::aws_smithy_legacy_http_server::protocol::accept_header_classifier(request.headers(), &crate::mimes::CONTENT_TYPE_APPLICATION_X_AMZ_JSON_1_0) {
                                return Err(::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection::NotAcceptable);
                            }
                        crate::protocol_serde::shape_put_item::de_put_item_http_request(request)
                            .await
                    };
                    use ::futures_util::future::TryFutureExt;
                    let fut = fut.map_err(|e: ::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection| {
                        ::tracing::debug!(error = %e, "failed to deserialize request");
                        ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e)
                    });
                    PutItemInputFuture {
                        inner: Box::pin(fut)
                    }
                }
            }
impl ::aws_smithy_legacy_http_server::response::IntoResponse<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0> for crate::output::PutItemOutput {
                fn into_response(self) -> ::aws_smithy_legacy_http_server::response::Response {
                    match crate::protocol_serde::shape_put_item::ser_put_item_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_legacy_http_server::response::IntoResponse::<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0>::into_response(::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e))
                        }
                    }
                }
            }
impl ::aws_smithy_legacy_http_server::response::IntoResponse<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0> for crate::error::PutItemError {
    fn into_response(self) -> ::aws_smithy_legacy_http_server::response::Response {
        match crate::protocol_serde::shape_put_item::ser_put_item_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(::aws_smithy_legacy_http_server::extension::ModeledErrorExtension::new(self.name()));
                response
            },
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_legacy_http_server::response::IntoResponse::<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0>::into_response(::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e))
            }
        }
    }
}


::pin_project_lite::pin_project! {
                /// A [`Future`](std::future::Future) aggregating the body bytes of a [`Request`] and constructing the
                /// [`GetItemInput`](crate::input::GetItemInput) using modelled bindings.
                pub struct GetItemInputFuture {
                    inner: std::pin::Pin<Box<dyn std::future::Future<Output = Result<crate::input::GetItemInput, ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError>> + Send>>
                }
            }

            impl std::future::Future for GetItemInputFuture {
                type Output = Result<crate::input::GetItemInput, ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError>;

                fn poll(self: std::pin::Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Self::Output> {
                    let this = self.project();
                    this.inner.as_mut().poll(cx)
                }
            }

            impl<B> ::aws_smithy_legacy_http_server::request::FromRequest<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0, B> for crate::input::GetItemInput
            where
                B: ::aws_smithy_legacy_http_server::body::HttpBody + Send,
                B: 'static,
                
                B::Data: Send,
                ::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection : From<<B as ::aws_smithy_legacy_http_server::body::HttpBody>::Error>
            {
                type Rejection = ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError;
                type Future = GetItemInputFuture;

                fn from_request(request: ::http::Request<B>) -> Self::Future {
                    let fut = async move {
                        if !::aws_smithy_legacy_http_server::protocol::accept_header_classifier(request.headers(), &crate::mimes::CONTENT_TYPE_APPLICATION_X_AMZ_JSON_1_0) {
                                return Err(::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection::NotAcceptable);
                            }
                        crate::protocol_serde::shape_get_item::de_get_item_http_request(request)
                            .await
                    };
                    use ::futures_util::future::TryFutureExt;
                    let fut = fut.map_err(|e: ::aws_smithy_legacy_http_server::protocol::aws_json::rejection::RequestRejection| {
                        ::tracing::debug!(error = %e, "failed to deserialize request");
                        ::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e)
                    });
                    GetItemInputFuture {
                        inner: Box::pin(fut)
                    }
                }
            }
impl ::aws_smithy_legacy_http_server::response::IntoResponse<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0> for crate::output::GetItemOutput {
                fn into_response(self) -> ::aws_smithy_legacy_http_server::response::Response {
                    match crate::protocol_serde::shape_get_item::ser_get_item_http_response(self) {
                        Ok(response) => response,
                        Err(e) => {
                            ::tracing::error!(error = %e, "failed to serialize response");
                            ::aws_smithy_legacy_http_server::response::IntoResponse::<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0>::into_response(::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e))
                        }
                    }
                }
            }
impl ::aws_smithy_legacy_http_server::response::IntoResponse<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0> for crate::error::GetItemError {
    fn into_response(self) -> ::aws_smithy_legacy_http_server::response::Response {
        match crate::protocol_serde::shape_get_item::ser_get_item_http_error(&self) {
            Ok(mut response) => {
                response.extensions_mut().insert(::aws_smithy_legacy_http_server::extension::ModeledErrorExtension::new(self.name()));
                response
            },
            Err(e) => {
                ::tracing::error!(error = %e, "failed to serialize response");
                ::aws_smithy_legacy_http_server::response::IntoResponse::<::aws_smithy_legacy_http_server::protocol::aws_json_10::AwsJson1_0>::into_response(::aws_smithy_legacy_http_server::protocol::aws_json::runtime_error::RuntimeError::from(e))
            }
        }
    }
}


